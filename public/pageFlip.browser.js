var St =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/PageFlip.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/Style/stPageFlip.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/Style/stPageFlip.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".stf__parent {\\r\\n  position: relative;\\r\\n  display: block;\\r\\n  box-sizing: border-box;\\r\\n  transform: translateZ(0);\\r\\n\\r\\n  -ms-touch-action: pan-y;\\r\\n  touch-action: pan-y;\\r\\n}\\r\\n\\r\\n.sft__wrapper {\\r\\n  position: relative;\\r\\n  width: 100%;\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.stf__parent canvas {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.stf__block {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  box-sizing: border-box;\\r\\n  perspective: 2000px;\\r\\n}\\r\\n\\r\\n.stf__item {\\r\\n  display: none;\\r\\n  position: absolute;\\r\\n  transform-style: preserve-3d;\\r\\n}\\r\\n\\r\\n.stf__outerShadow {\\r\\n  position: absolute;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.stf__innerShadow {\\r\\n  position: absolute;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.stf__hardShadow {\\r\\n  position: absolute;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.stf__hardInnerShadow {\\r\\n  position: absolute;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack://St/./src/Style/stPageFlip.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack://St/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://St/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./src/Collection/HTMLPageCollection.ts":
/*!**********************************************!*\
  !*** ./src/Collection/HTMLPageCollection.ts ***!
  \**********************************************/
/*! exports provided: HTMLPageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLPageCollection\", function() { return HTMLPageCollection; });\n/* harmony import */ var _Page_HTMLPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Page/HTMLPage */ \"./src/Page/HTMLPage.ts\");\n/* harmony import */ var _PageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageCollection */ \"./src/Collection/PageCollection.ts\");\n\r\n\r\n/**\r\n * 小lass representing a collection of pages as HTML Element\r\n */\r\nclass HTMLPageCollection extends _PageCollection__WEBPACK_IMPORTED_MODULE_1__[\"PageCollection\"] {\r\n    constructor(app, render, element, items) {\r\n        super(app, render);\r\n        this.element = element;\r\n        this.pagesElement = items;\r\n    }\r\n    load() {\r\n        for (const pageElement of this.pagesElement) {\r\n            const page = new _Page_HTMLPage__WEBPACK_IMPORTED_MODULE_0__[\"HTMLPage\"](this.render, pageElement, pageElement.dataset['density'] === 'hard' ? \"hard\" /* HARD */ : \"soft\" /* SOFT */);\r\n            page.load();\r\n            this.pages.push(page);\r\n        }\r\n        this.createSpread();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Collection/HTMLPageCollection.ts?");

/***/ }),

/***/ "./src/Collection/ImagePageCollection.ts":
/*!***********************************************!*\
  !*** ./src/Collection/ImagePageCollection.ts ***!
  \***********************************************/
/*! exports provided: ImagePageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImagePageCollection\", function() { return ImagePageCollection; });\n/* harmony import */ var _Page_ImagePage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Page/ImagePage */ \"./src/Page/ImagePage.ts\");\n/* harmony import */ var _PageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageCollection */ \"./src/Collection/PageCollection.ts\");\n\r\n\r\n/**\r\n * 小lass representing a collection of pages as images on the canvas\r\n */\r\nclass ImagePageCollection extends _PageCollection__WEBPACK_IMPORTED_MODULE_1__[\"PageCollection\"] {\r\n    constructor(app, render, imagesHref) {\r\n        super(app, render);\r\n        this.imagesHref = imagesHref;\r\n    }\r\n    load() {\r\n        for (const href of this.imagesHref) {\r\n            const page = new _Page_ImagePage__WEBPACK_IMPORTED_MODULE_0__[\"ImagePage\"](this.render, href, \"soft\" /* SOFT */);\r\n            page.load();\r\n            this.pages.push(page);\r\n        }\r\n        this.createSpread();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Collection/ImagePageCollection.ts?");

/***/ }),

/***/ "./src/Collection/PageCollection.ts":
/*!******************************************!*\
  !*** ./src/Collection/PageCollection.ts ***!
  \******************************************/
/*! exports provided: PageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageCollection\", function() { return PageCollection; });\n/**\r\n * 小lass representing a collection of pages\r\n */\r\nclass PageCollection {\r\n    constructor(app, render) {\r\n        /** Pages List */\r\n        this.pages = [];\r\n        /** Index of the current page in list */\r\n        this.currentPageIndex = 0;\r\n        /** Number of the current spread in book */\r\n        this.currentSpreadIndex = 0;\r\n        /**  Two-page spread in landscape mode */\r\n        this.landscapeSpread = [];\r\n        /**  One-page spread in portrait mode */\r\n        this.portraitSpread = [];\r\n        this.render = render;\r\n        this.app = app;\r\n        this.currentPageIndex = 0;\r\n        this.isShowCover = this.app.getSettings().showCover;\r\n    }\r\n    /**\r\n     * Clear pages list\r\n     */\r\n    destroy() {\r\n        this.pages = [];\r\n    }\r\n    /**\r\n     * Split the book on the two-page spread in landscape mode and one-page spread in portrait mode\r\n     */\r\n    createSpread() {\r\n        this.landscapeSpread = [];\r\n        this.portraitSpread = [];\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.portraitSpread.push([i]); // In portrait mode - (one spread = one page)\r\n        }\r\n        let start = 0;\r\n        if (this.isShowCover) {\r\n            this.pages[0].setDensity(\"hard\" /* HARD */);\r\n            this.landscapeSpread.push([start]);\r\n            start++;\r\n        }\r\n        for (let i = start; i < this.pages.length; i += 2) {\r\n            if (i < this.pages.length - 1)\r\n                this.landscapeSpread.push([i, i + 1]);\r\n            else {\r\n                this.landscapeSpread.push([i]);\r\n                this.pages[i].setDensity(\"hard\" /* HARD */);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get spread by mode (portrait or landscape)\r\n     */\r\n    getSpread() {\r\n        return this.render.getOrientation() === \"landscape\" /* LANDSCAPE */\r\n            ? this.landscapeSpread\r\n            : this.portraitSpread;\r\n    }\r\n    /**\r\n     * Get spread index by page number\r\n     *\r\n     * @param {number} pageNum - page index\r\n     */\r\n    getSpreadIndexByPage(pageNum) {\r\n        const spread = this.getSpread();\r\n        for (let i = 0; i < spread.length; i++)\r\n            if (pageNum === spread[i][0] || pageNum === spread[i][1])\r\n                return i;\r\n        return null;\r\n    }\r\n    /**\r\n     * Get the total number of pages\r\n     */\r\n    getPageCount() {\r\n        return this.pages.length;\r\n    }\r\n    /**\r\n     * Get the pages list\r\n     */\r\n    getPages() {\r\n        return this.pages;\r\n    }\r\n    /**\r\n     * Get page by index\r\n     *\r\n     * @param {number} pageIndex\r\n     */\r\n    getPage(pageIndex) {\r\n        if (pageIndex >= 0 && pageIndex < this.pages.length) {\r\n            return this.pages[pageIndex];\r\n        }\r\n        throw new Error('Invalid page number');\r\n    }\r\n    /**\r\n     * Get the next page from the specified\r\n     *\r\n     * @param {Page} current\r\n     */\r\n    nextBy(current) {\r\n        const idx = this.pages.indexOf(current);\r\n        if (idx < this.pages.length - 1)\r\n            return this.pages[idx + 1];\r\n        return null;\r\n    }\r\n    /**\r\n     * Get previous page from specified\r\n     *\r\n     * @param {Page} current\r\n     */\r\n    prevBy(current) {\r\n        const idx = this.pages.indexOf(current);\r\n        if (idx > 0)\r\n            return this.pages[idx - 1];\r\n        return null;\r\n    }\r\n    /**\r\n     * Get flipping page depending on the direction\r\n     *\r\n     * @param {FlipDirection} direction\r\n     */\r\n    getFlippingPage(direction) {\r\n        const current = this.currentSpreadIndex;\r\n        if (this.render.getOrientation() === \"portrait\" /* PORTRAIT */) {\r\n            return direction === 0 /* FORWARD */\r\n                ? this.pages[current].newTemporaryCopy()\r\n                : this.pages[current - 1];\r\n        }\r\n        else {\r\n            const spread = direction === 0 /* FORWARD */\r\n                ? this.getSpread()[current + 1]\r\n                : this.getSpread()[current - 1];\r\n            if (spread.length === 1)\r\n                return this.pages[spread[0]];\r\n            return direction === 0 /* FORWARD */\r\n                ? this.pages[spread[0]]\r\n                : this.pages[spread[1]];\r\n        }\r\n    }\r\n    /**\r\n     * Get Next page at the time of flipping\r\n     *\r\n     * @param {FlipDirection}  direction\r\n     */\r\n    getBottomPage(direction) {\r\n        const current = this.currentSpreadIndex;\r\n        if (this.render.getOrientation() === \"portrait\" /* PORTRAIT */) {\r\n            return direction === 0 /* FORWARD */\r\n                ? this.pages[current + 1]\r\n                : this.pages[current - 1];\r\n        }\r\n        else {\r\n            const spread = direction === 0 /* FORWARD */\r\n                ? this.getSpread()[current + 1]\r\n                : this.getSpread()[current - 1];\r\n            if (spread.length === 1)\r\n                return this.pages[spread[0]];\r\n            return direction === 0 /* FORWARD */\r\n                ? this.pages[spread[1]]\r\n                : this.pages[spread[0]];\r\n        }\r\n    }\r\n    /**\r\n     * Show next spread\r\n     */\r\n    showNext() {\r\n        if (this.currentSpreadIndex < this.getSpread().length) {\r\n            this.currentSpreadIndex++;\r\n            this.showSpread();\r\n        }\r\n    }\r\n    /**\r\n     * Show prev spread\r\n     */\r\n    showPrev() {\r\n        if (this.currentSpreadIndex > 0) {\r\n            this.currentSpreadIndex--;\r\n            this.showSpread();\r\n        }\r\n    }\r\n    /**\r\n     * Get the number of the current spread in book\r\n     */\r\n    getCurrentPageIndex() {\r\n        return this.currentPageIndex;\r\n    }\r\n    /**\r\n     * Show specified page\r\n     * @param {number} pageNum - Page index (from 0s)\r\n     */\r\n    show(pageNum = null) {\r\n        if (pageNum === null)\r\n            pageNum = this.currentPageIndex;\r\n        if (pageNum < 0 || pageNum >= this.pages.length)\r\n            return;\r\n        const spreadIndex = this.getSpreadIndexByPage(pageNum);\r\n        if (spreadIndex !== null) {\r\n            this.currentSpreadIndex = spreadIndex;\r\n            this.showSpread();\r\n        }\r\n    }\r\n    /**\r\n     * Index of the current page in list\r\n     */\r\n    getCurrentSpreadIndex() {\r\n        return this.currentSpreadIndex;\r\n    }\r\n    /**\r\n     * Set new spread index as current\r\n     *\r\n     * @param {number} newIndex - new spread index\r\n     */\r\n    setCurrentSpreadIndex(newIndex) {\r\n        if (newIndex >= 0 && newIndex < this.getSpread().length) {\r\n            this.currentSpreadIndex = newIndex;\r\n        }\r\n        else {\r\n            throw new Error('Invalid page');\r\n        }\r\n    }\r\n    /**\r\n     * Show current spread\r\n     */\r\n    showSpread() {\r\n        const spread = this.getSpread()[this.currentSpreadIndex];\r\n        if (spread.length === 2) {\r\n            this.render.setLeftPage(this.pages[spread[0]]);\r\n            this.render.setRightPage(this.pages[spread[1]]);\r\n        }\r\n        else {\r\n            if (this.render.getOrientation() === \"landscape\" /* LANDSCAPE */) {\r\n                if (spread[0] === this.pages.length - 1) {\r\n                    this.render.setLeftPage(this.pages[spread[0]]);\r\n                    this.render.setRightPage(null);\r\n                }\r\n                else {\r\n                    this.render.setLeftPage(null);\r\n                    this.render.setRightPage(this.pages[spread[0]]);\r\n                }\r\n            }\r\n            else {\r\n                this.render.setLeftPage(null);\r\n                this.render.setRightPage(this.pages[spread[0]]);\r\n            }\r\n        }\r\n        this.currentPageIndex = spread[0];\r\n        this.app.updatePageIndex(this.currentPageIndex);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Collection/PageCollection.ts?");

/***/ }),

/***/ "./src/Event/EventObject.ts":
/*!**********************************!*\
  !*** ./src/Event/EventObject.ts ***!
  \**********************************/
/*! exports provided: EventObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventObject\", function() { return EventObject; });\n/**\r\n * A class implementing a basic event model\r\n */\r\nclass EventObject {\r\n    constructor() {\r\n        this.events = new Map();\r\n    }\r\n    /**\r\n     * Add new event handler\r\n     *\r\n     * @param {string} eventName\r\n     * @param {EventCallback} callback\r\n     */\r\n    on(eventName, callback) {\r\n        if (!this.events.has(eventName)) {\r\n            this.events.set(eventName, [callback]);\r\n        }\r\n        else {\r\n            this.events.get(eventName).push(callback);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Removing all handlers from an event\r\n     *\r\n     * @param {string} event - Event name\r\n     */\r\n    off(event) {\r\n        this.events.delete(event);\r\n    }\r\n    trigger(eventName, app, data = null) {\r\n        if (!this.events.has(eventName))\r\n            return;\r\n        for (const callback of this.events.get(eventName)) {\r\n            callback({ data, object: app });\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Event/EventObject.ts?");

/***/ }),

/***/ "./src/Flip/Flip.ts":
/*!**************************!*\
  !*** ./src/Flip/Flip.ts ***!
  \**************************/
/*! exports provided: Flip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Flip\", function() { return Flip; });\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper */ \"./src/Helper.ts\");\n/* harmony import */ var _FlipCalculation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlipCalculation */ \"./src/Flip/FlipCalculation.ts\");\n\r\n\r\n/**\r\n * Class representing the flipping process\r\n */\r\nclass Flip {\r\n    constructor(render, app) {\r\n        this.flippingPage = null;\r\n        this.bottomPage = null;\r\n        this.calc = null;\r\n        this.state = \"read\" /* READ */;\r\n        this.render = render;\r\n        this.app = app;\r\n    }\r\n    /**\r\n     * Called when the page folding (User drags page corner)\r\n     *\r\n     * @param globalPos - Touch Point Coordinates (relative window)\r\n     */\r\n    fold(globalPos) {\r\n        this.setState(\"user_fold\" /* USER_FOLD */);\r\n        // If the process has not started yet\r\n        if (this.calc === null)\r\n            this.start(globalPos);\r\n        this.do(this.render.convertToPage(globalPos));\r\n    }\r\n    /**\r\n     * Page turning with animation\r\n     *\r\n     * @param globalPos - Touch Point Coordinates (relative window)\r\n     */\r\n    flip(globalPos) {\r\n        // the flipiing process is already running\r\n        if (this.calc !== null)\r\n            this.render.finishAnimation();\r\n        if (!this.start(globalPos))\r\n            return;\r\n        const rect = this.getBoundsRect();\r\n        this.setState(\"flipping\" /* FLIPPING */);\r\n        // Margin from top to start flipping\r\n        const topMargins = rect.height / 10;\r\n        // Defining animation start points\r\n        const yStart = this.calc.getCorner() === \"bottom\" /* BOTTOM */ ? rect.height - topMargins : topMargins;\r\n        const yDest = this.calc.getCorner() === \"bottom\" /* BOTTOM */ ? rect.height : 0;\r\n        // 小alculations for these points\r\n        this.calc.calc({ x: rect.pageWidth - topMargins, y: yStart });\r\n        // Run flipping animation\r\n        this.animateFlippingTo({ x: rect.pageWidth - topMargins, y: yStart }, { x: -rect.pageWidth, y: yDest }, true);\r\n    }\r\n    /**\r\n     * Start the flipping process. Find direction and corner of flipping. Creating an object for calculation.\r\n     *\r\n     * @param {Point} globalPos - Touch Point Coordinates (relative window)\r\n     *\r\n     * @returns {boolean} True if flipping is possible, false otherwise\r\n     */\r\n    start(globalPos) {\r\n        this.reset();\r\n        const bookPos = this.render.convertToBook(globalPos);\r\n        const rect = this.getBoundsRect();\r\n        // Find the direction of flipping\r\n        const direction = this.getDirectionByPoint(bookPos);\r\n        // Find the active corner\r\n        const flipCorner = bookPos.y >= rect.height / 2 ? \"bottom\" /* BOTTOM */ : \"top\" /* TOP */;\r\n        if (!this.checkDirection(direction))\r\n            return false;\r\n        try {\r\n            this.flippingPage = this.app.getPageCollection().getFlippingPage(direction);\r\n            this.bottomPage = this.app.getPageCollection().getBottomPage(direction);\r\n            // In landscape mode, needed to set the density  of the next page to the same as that of the flipped\r\n            if (this.render.getOrientation() === \"landscape\" /* LANDSCAPE */) {\r\n                if (direction === 1 /* BACK */) {\r\n                    const nextPage = this.app.getPageCollection().nextBy(this.flippingPage);\r\n                    if (nextPage !== null) {\r\n                        if (this.flippingPage.getDensity() !== nextPage.getDensity()) {\r\n                            this.flippingPage.setDrawingDensity(\"hard\" /* HARD */);\r\n                            nextPage.setDrawingDensity(\"hard\" /* HARD */);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    const prevPage = this.app.getPageCollection().prevBy(this.flippingPage);\r\n                    if (prevPage !== null) {\r\n                        if (this.flippingPage.getDensity() !== prevPage.getDensity()) {\r\n                            this.flippingPage.setDrawingDensity(\"hard\" /* HARD */);\r\n                            prevPage.setDrawingDensity(\"hard\" /* HARD */);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.render.setDirection(direction);\r\n            this.calc = new _FlipCalculation__WEBPACK_IMPORTED_MODULE_1__[\"FlipCalculation\"](direction, flipCorner, rect.pageWidth.toString(10), // fix bug with type casting\r\n            rect.height.toString(10) // fix bug with type casting\r\n            );\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Perform calculations for the current page position. Pass data to render object\r\n     *\r\n     * @param {Point} pagePos - Touch Point Coordinates (relative active page)\r\n     */\r\n    do(pagePos) {\r\n        if (this.calc === null)\r\n            return; // Flipping process not started\r\n        if (this.calc.calc(pagePos)) { // Perform calculations for a specific position\r\n            const progress = this.calc.getFlippingProgress();\r\n            this.bottomPage.setArea(this.calc.getBottomClipArea());\r\n            this.bottomPage.setPosition(this.calc.getBottomPagePosition());\r\n            this.bottomPage.setAngle(0);\r\n            this.bottomPage.setHardAngle(0);\r\n            this.flippingPage.setArea(this.calc.getFlippingClipArea());\r\n            this.flippingPage.setPosition(this.calc.getActiveCorner());\r\n            this.flippingPage.setAngle(this.calc.getAngle());\r\n            if (this.calc.getDirection() === 0 /* FORWARD */) {\r\n                this.flippingPage.setHardAngle((90 * (200 - progress * 2)) / 100);\r\n            }\r\n            else {\r\n                this.flippingPage.setHardAngle((-90 * (200 - progress * 2)) / 100);\r\n            }\r\n            this.render.setPageRect(this.calc.getRect());\r\n            this.render.setBottomPage(this.bottomPage);\r\n            this.render.setFlippingPage(this.flippingPage);\r\n            this.render.setShadowData(this.calc.getShadowStartPoint(), this.calc.getShadowAngle(), progress, this.calc.getDirection());\r\n        }\r\n    }\r\n    /**\r\n     * Turn to the specified page number (with animation)\r\n     *\r\n     * @param {number} page - New page number\r\n     * @param {FlipCorner} corner - Active page corner when turning\r\n     */\r\n    flipToPage(page, corner) {\r\n        const current = this.app.getPageCollection().getCurrentSpreadIndex();\r\n        const next = this.app.getPageCollection().getSpreadIndexByPage(page);\r\n        try {\r\n            if (next > current) {\r\n                this.app.getPageCollection().setCurrentSpreadIndex(next - 1);\r\n                this.flipNext(corner);\r\n            }\r\n            if (next < current) {\r\n                this.app.getPageCollection().setCurrentSpreadIndex(next + 1);\r\n                this.flipPrev(corner);\r\n            }\r\n        }\r\n        catch (e) {\r\n            //\r\n        }\r\n    }\r\n    /**\r\n     * Turn to the next page (with animation)\r\n     *\r\n     * @param {FlipCorner} corner - Active page corner when turning\r\n     */\r\n    flipNext(corner) {\r\n        this.flip({\r\n            x: this.render.getRect().left + this.render.getRect().pageWidth * 2,\r\n            y: corner === \"top\" /* TOP */ ? 1 : this.render.getRect().height - 2,\r\n        });\r\n    }\r\n    /**\r\n     * Turn to the prev page (with animation)\r\n     *\r\n     * @param {FlipCorner} corner - Active page corner when turning\r\n     */\r\n    flipPrev(corner) {\r\n        this.flip({\r\n            x: 10,\r\n            y: corner === \"top\" /* TOP */ ? 1 : this.render.getRect().height - 2,\r\n        });\r\n    }\r\n    /**\r\n     * Called when the user has stopped flipping\r\n     */\r\n    stopMove() {\r\n        if (this.calc === null)\r\n            return;\r\n        const pos = this.calc.getPosition();\r\n        const rect = this.getBoundsRect();\r\n        const y = this.calc.getCorner() === \"bottom\" /* BOTTOM */ ? rect.height : 0;\r\n        if (pos.x <= 0)\r\n            this.animateFlippingTo(pos, { x: -rect.pageWidth, y }, true);\r\n        else\r\n            this.animateFlippingTo(pos, { x: rect.pageWidth, y }, false);\r\n    }\r\n    /**\r\n     * Fold the corners of the book when the mouse pointer is over them.\r\n     * Called when the mouse pointer is over the book without clicking\r\n     *\r\n     * @param globalPos\r\n     */\r\n    showCorner(globalPos) {\r\n        if (!this.checkState(\"read\" /* READ */, \"fold_corner\" /* FOLD_CORNER */))\r\n            return;\r\n        const rect = this.getBoundsRect();\r\n        const pageWidth = rect.pageWidth;\r\n        // folding angle length\r\n        const operatingDistance = Math.sqrt(Math.pow(pageWidth, 2) + Math.pow(rect.height, 2)) / 5;\r\n        const bookPos = this.render.convertToBook(globalPos);\r\n        if (bookPos.x > 0 &&\r\n            bookPos.y > 0 &&\r\n            bookPos.x < rect.width &&\r\n            bookPos.y < rect.height &&\r\n            (bookPos.x < operatingDistance || bookPos.x > rect.width - operatingDistance) &&\r\n            (bookPos.y < operatingDistance || bookPos.y > rect.height - operatingDistance)) {\r\n            if (this.calc === null) {\r\n                if (!this.start(globalPos))\r\n                    return;\r\n                this.setState(\"fold_corner\" /* FOLD_CORNER */);\r\n                this.calc.calc({ x: pageWidth - 1, y: 1 });\r\n                const fixedCornerSize = 50;\r\n                const yStart = this.calc.getCorner() === \"bottom\" /* BOTTOM */ ? rect.height - 1 : 1;\r\n                const yDest = this.calc.getCorner() === \"bottom\" /* BOTTOM */\r\n                    ? rect.height - fixedCornerSize\r\n                    : fixedCornerSize;\r\n                this.animateFlippingTo({ x: pageWidth - 1, y: yStart }, { x: pageWidth - fixedCornerSize, y: yDest }, false, false);\r\n            }\r\n            else {\r\n                this.do(this.render.convertToPage(globalPos));\r\n            }\r\n        }\r\n        else {\r\n            this.setState(\"read\" /* READ */);\r\n            this.render.finishAnimation();\r\n            this.stopMove();\r\n        }\r\n    }\r\n    /**\r\n     * Starting the flipping animation process\r\n     *\r\n     * @param {Point} start - animation start point\r\n     * @param {Point} dest - animation end point\r\n     * @param {boolean} isTurned - will the page turn over, or just bring it back\r\n     * @param {boolean} needReset - reset the flipping process at the end of the animation\r\n     */\r\n    animateFlippingTo(start, dest, isTurned, needReset = true) {\r\n        const points = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetCordsFromTwoPoint(start, dest);\r\n        // Create frames\r\n        const frames = [];\r\n        for (const p of points)\r\n            frames.push(() => this.do(p));\r\n        const duration = this.getAnimationDuration(points.length);\r\n        this.render.startAnimation(frames, duration, () => {\r\n            // callback function\r\n            if (!this.calc)\r\n                return;\r\n            if (isTurned) {\r\n                if (this.calc.getDirection() === 1 /* BACK */)\r\n                    this.app.turnToPrevPage();\r\n                else\r\n                    this.app.turnToNextPage();\r\n            }\r\n            if (needReset) {\r\n                this.render.setBottomPage(null);\r\n                this.render.setFlippingPage(null);\r\n                this.render.clearShadow();\r\n                this.setState(\"read\" /* READ */);\r\n                this.reset();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Get the current calculations object\r\n     */\r\n    getCalculation() {\r\n        return this.calc;\r\n    }\r\n    /**\r\n     * Get current flipping state\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    setState(newState) {\r\n        if (this.state !== newState) {\r\n            this.app.updateState(newState);\r\n            this.state = newState;\r\n        }\r\n    }\r\n    getDirectionByPoint(touchPos) {\r\n        const rect = this.getBoundsRect();\r\n        if (this.render.getOrientation() === \"portrait\" /* PORTRAIT */) {\r\n            if (touchPos.x - rect.pageWidth <= rect.width / 5) {\r\n                return 1 /* BACK */;\r\n            }\r\n        }\r\n        else if (touchPos.x < rect.width / 2) {\r\n            return 1 /* BACK */;\r\n        }\r\n        return 0 /* FORWARD */;\r\n    }\r\n    getAnimationDuration(size) {\r\n        const defaultTime = this.app.getSettings().flippingTime;\r\n        if (size >= 1000)\r\n            return defaultTime;\r\n        return (size / 1000) * defaultTime;\r\n    }\r\n    checkDirection(direction) {\r\n        if (direction === 0 /* FORWARD */)\r\n            return this.app.getCurrentPageIndex() < this.app.getPageCount() - 1;\r\n        return this.app.getCurrentPageIndex() >= 1;\r\n    }\r\n    reset() {\r\n        this.calc = null;\r\n        this.flippingPage = null;\r\n        this.bottomPage = null;\r\n    }\r\n    getBoundsRect() {\r\n        return this.render.getRect();\r\n    }\r\n    checkState(...states) {\r\n        for (const state of states) {\r\n            if (this.state === state)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Flip/Flip.ts?");

/***/ }),

/***/ "./src/Flip/FlipCalculation.ts":
/*!*************************************!*\
  !*** ./src/Flip/FlipCalculation.ts ***!
  \*************************************/
/*! exports provided: FlipCalculation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlipCalculation\", function() { return FlipCalculation; });\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper */ \"./src/Helper.ts\");\n\r\n/**\r\n * Class representing mathematical methods for calculating page position (rotation angle, clip area ...)\r\n */\r\nclass FlipCalculation {\r\n    /**\r\n     * @constructor\r\n     *\r\n     * @param {FlipDirection} direction - Flipping direction\r\n     * @param {FlipCorner} corner - Flipping corner\r\n     * @param pageWidth - Current page width\r\n     * @param pageHeight - Current page height\r\n     */\r\n    constructor(direction, corner, pageWidth, pageHeight) {\r\n        this.direction = direction;\r\n        this.corner = corner;\r\n        /** The point of intersection of the page with the borders of the book */\r\n        this.topIntersectPoint = null; // With top border\r\n        this.sideIntersectPoint = null; // With side border\r\n        this.bottomIntersectPoint = null; // With bottom border\r\n        this.pageWidth = parseInt(pageWidth, 10);\r\n        this.pageHeight = parseInt(pageHeight, 10);\r\n    }\r\n    /**\r\n     * The main calculation method\r\n     *\r\n     * @param {Point} localPos - Touch Point Coordinates (relative active page!)\r\n     *\r\n     * @returns {boolean} True - if the calculations were successful, false if errors occurred\r\n     */\r\n    calc(localPos) {\r\n        try {\r\n            // Find: page rotation angle and active corner position\r\n            this.position = this.calcAngleAndPosition(localPos);\r\n            // Find the intersection points of the scrolling page and the book\r\n            this.calculateIntersectPoint(this.position);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Get the crop area for the flipping page\r\n     *\r\n     * @returns {Point[]} Polygon page\r\n     */\r\n    getFlippingClipArea() {\r\n        const result = [];\r\n        let clipBottom = false;\r\n        result.push(this.rect.topLeft);\r\n        result.push(this.topIntersectPoint);\r\n        if (this.sideIntersectPoint === null) {\r\n            clipBottom = true;\r\n        }\r\n        else {\r\n            result.push(this.sideIntersectPoint);\r\n            if (this.bottomIntersectPoint === null)\r\n                clipBottom = false;\r\n        }\r\n        result.push(this.bottomIntersectPoint);\r\n        if (clipBottom || this.corner === \"bottom\" /* BOTTOM */) {\r\n            result.push(this.rect.bottomLeft);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Get the crop area for the page that is below the page to be flipped\r\n     *\r\n     * @returns {Point[]} Polygon page\r\n     */\r\n    getBottomClipArea() {\r\n        const result = [];\r\n        result.push(this.topIntersectPoint);\r\n        if (this.corner === \"top\" /* TOP */) {\r\n            result.push({ x: this.pageWidth, y: 0 });\r\n        }\r\n        else {\r\n            if (this.topIntersectPoint !== null) {\r\n                result.push({ x: this.pageWidth, y: 0 });\r\n            }\r\n            result.push({ x: this.pageWidth, y: this.pageHeight });\r\n        }\r\n        if (this.sideIntersectPoint !== null) {\r\n            if (_Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetDistanceBetweenTwoPoint(this.sideIntersectPoint, this.topIntersectPoint) >= 10)\r\n                result.push(this.sideIntersectPoint);\r\n        }\r\n        else {\r\n            if (this.corner === \"top\" /* TOP */) {\r\n                result.push({ x: this.pageWidth, y: this.pageHeight });\r\n            }\r\n        }\r\n        result.push(this.bottomIntersectPoint);\r\n        result.push(this.topIntersectPoint);\r\n        return result;\r\n    }\r\n    /**\r\n     * Get page rotation angle\r\n     */\r\n    getAngle() {\r\n        if (this.direction === 0 /* FORWARD */) {\r\n            return -this.angle;\r\n        }\r\n        return this.angle;\r\n    }\r\n    /**\r\n     * Get page area while flipping\r\n     */\r\n    getRect() {\r\n        return this.rect;\r\n    }\r\n    /**\r\n     * Get the position of the active angle when turning\r\n     */\r\n    getPosition() {\r\n        return this.position;\r\n    }\r\n    /**\r\n     * Get the active corner of the page (which pull)\r\n     */\r\n    getActiveCorner() {\r\n        if (this.direction === 0 /* FORWARD */) {\r\n            return this.rect.topLeft;\r\n        }\r\n        return this.rect.topRight;\r\n    }\r\n    /**\r\n     * Get flipping direction\r\n     */\r\n    getDirection() {\r\n        return this.direction;\r\n    }\r\n    /**\r\n     * Get flipping progress (0-100)\r\n     */\r\n    getFlippingProgress() {\r\n        return Math.abs(((this.position.x - this.pageWidth) / (2 * this.pageWidth)) * 100);\r\n    }\r\n    /**\r\n     * Get flipping corner position (top, bottom)\r\n     */\r\n    getCorner() {\r\n        return this.corner;\r\n    }\r\n    /**\r\n     * Get start position for the page that is below the page to be flipped\r\n     */\r\n    getBottomPagePosition() {\r\n        if (this.direction === 1 /* BACK */) {\r\n            return { x: this.pageWidth, y: 0 };\r\n        }\r\n        return { x: 0, y: 0 };\r\n    }\r\n    /**\r\n     * Get the starting position of the shadow\r\n     */\r\n    getShadowStartPoint() {\r\n        if (this.corner === \"top\" /* TOP */) {\r\n            return this.topIntersectPoint;\r\n        }\r\n        else {\r\n            if (this.sideIntersectPoint !== null)\r\n                return this.sideIntersectPoint;\r\n            return this.topIntersectPoint;\r\n        }\r\n    }\r\n    /**\r\n     * Get the rotate angle of the shadow\r\n     */\r\n    getShadowAngle() {\r\n        const angle = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetAngleBetweenTwoLine(this.getSegmentToShadowLine(), [\r\n            { x: 0, y: 0 },\r\n            { x: this.pageWidth, y: 0 },\r\n        ]);\r\n        if (this.direction === 0 /* FORWARD */) {\r\n            return angle;\r\n        }\r\n        return Math.PI - angle;\r\n    }\r\n    calcAngleAndPosition(pos) {\r\n        let result = pos;\r\n        this.updateAngleAndGeometry(result);\r\n        if (this.corner === \"top\" /* TOP */) {\r\n            result = this.checkPositionAtCenterLine(result, { x: 0, y: 0 }, { x: 0, y: this.pageHeight });\r\n        }\r\n        else {\r\n            result = this.checkPositionAtCenterLine(result, { x: 0, y: this.pageHeight }, { x: 0, y: 0 });\r\n        }\r\n        if (Math.abs(result.x - this.pageWidth) < 1 && Math.abs(result.y) < 1) {\r\n            throw new Error('Point is too small');\r\n        }\r\n        return result;\r\n    }\r\n    updateAngleAndGeometry(pos) {\r\n        this.angle = this.calculateAngle(pos);\r\n        this.rect = this.getPageRect(pos);\r\n    }\r\n    calculateAngle(pos) {\r\n        const left = this.pageWidth - pos.x + 1;\r\n        const top = this.corner === \"bottom\" /* BOTTOM */ ? this.pageHeight - pos.y : pos.y;\r\n        let angle = 2 * Math.acos(left / Math.sqrt(top * top + left * left));\r\n        if (top < 0)\r\n            angle = -angle;\r\n        const da = Math.PI - angle;\r\n        if (!isFinite(angle) || (da >= 0 && da < 0.003))\r\n            throw new Error('The G point is too small');\r\n        if (this.corner === \"bottom\" /* BOTTOM */)\r\n            angle = -angle;\r\n        return angle;\r\n    }\r\n    getPageRect(localPos) {\r\n        if (this.corner === \"top\" /* TOP */) {\r\n            return this.getRectFromBasePoint([\r\n                { x: 0, y: 0 },\r\n                { x: this.pageWidth, y: 0 },\r\n                { x: 0, y: this.pageHeight },\r\n                { x: this.pageWidth, y: this.pageHeight },\r\n            ], localPos);\r\n        }\r\n        return this.getRectFromBasePoint([\r\n            { x: 0, y: -this.pageHeight },\r\n            { x: this.pageWidth, y: -this.pageHeight },\r\n            { x: 0, y: 0 },\r\n            { x: this.pageWidth, y: 0 },\r\n        ], localPos);\r\n    }\r\n    getRectFromBasePoint(points, localPos) {\r\n        return {\r\n            topLeft: this.getRotatedPoint(points[0], localPos),\r\n            topRight: this.getRotatedPoint(points[1], localPos),\r\n            bottomLeft: this.getRotatedPoint(points[2], localPos),\r\n            bottomRight: this.getRotatedPoint(points[3], localPos),\r\n        };\r\n    }\r\n    getRotatedPoint(transformedPoint, startPoint) {\r\n        return {\r\n            x: transformedPoint.x * Math.cos(this.angle) +\r\n                transformedPoint.y * Math.sin(this.angle) +\r\n                startPoint.x,\r\n            y: transformedPoint.y * Math.cos(this.angle) -\r\n                transformedPoint.x * Math.sin(this.angle) +\r\n                startPoint.y,\r\n        };\r\n    }\r\n    calculateIntersectPoint(pos) {\r\n        const boundRect = {\r\n            left: -1,\r\n            top: -1,\r\n            width: this.pageWidth + 2,\r\n            height: this.pageHeight + 2,\r\n        };\r\n        if (this.corner === \"top\" /* TOP */) {\r\n            this.topIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectBetweenTwoSegment(boundRect, [pos, this.rect.topRight], [\r\n                { x: 0, y: 0 },\r\n                { x: this.pageWidth, y: 0 },\r\n            ]);\r\n            this.sideIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectBetweenTwoSegment(boundRect, [pos, this.rect.bottomLeft], [\r\n                { x: this.pageWidth, y: 0 },\r\n                { x: this.pageWidth, y: this.pageHeight },\r\n            ]);\r\n            this.bottomIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectBetweenTwoSegment(boundRect, [this.rect.bottomLeft, this.rect.bottomRight], [\r\n                { x: 0, y: this.pageHeight },\r\n                { x: this.pageWidth, y: this.pageHeight },\r\n            ]);\r\n        }\r\n        else {\r\n            this.topIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectBetweenTwoSegment(boundRect, [this.rect.topLeft, this.rect.topRight], [\r\n                { x: 0, y: 0 },\r\n                { x: this.pageWidth, y: 0 },\r\n            ]);\r\n            this.sideIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectBetweenTwoSegment(boundRect, [pos, this.rect.topLeft], [\r\n                { x: this.pageWidth, y: 0 },\r\n                { x: this.pageWidth, y: this.pageHeight },\r\n            ]);\r\n            this.bottomIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectBetweenTwoSegment(boundRect, [this.rect.bottomLeft, this.rect.bottomRight], [\r\n                { x: 0, y: this.pageHeight },\r\n                { x: this.pageWidth, y: this.pageHeight },\r\n            ]);\r\n        }\r\n    }\r\n    checkPositionAtCenterLine(checkedPos, centerOne, centerTwo) {\r\n        let result = checkedPos;\r\n        const tmp = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].LimitPointToCircle(centerOne, this.pageWidth, result);\r\n        if (result !== tmp) {\r\n            result = tmp;\r\n            this.updateAngleAndGeometry(result);\r\n        }\r\n        const rad = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));\r\n        let checkPointOne = this.rect.bottomRight;\r\n        let checkPointTwo = this.rect.topLeft;\r\n        if (this.corner === \"bottom\" /* BOTTOM */) {\r\n            checkPointOne = this.rect.topRight;\r\n            checkPointTwo = this.rect.bottomLeft;\r\n        }\r\n        if (checkPointOne.x <= 0) {\r\n            const bottomPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].LimitPointToCircle(centerTwo, rad, checkPointTwo);\r\n            if (bottomPoint !== result) {\r\n                result = bottomPoint;\r\n                this.updateAngleAndGeometry(result);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getSegmentToShadowLine() {\r\n        const first = this.getShadowStartPoint();\r\n        const second = first !== this.sideIntersectPoint && this.sideIntersectPoint !== null\r\n            ? this.sideIntersectPoint\r\n            : this.bottomIntersectPoint;\r\n        return [first, second];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Flip/FlipCalculation.ts?");

/***/ }),

/***/ "./src/Helper.ts":
/*!***********************!*\
  !*** ./src/Helper.ts ***!
  \***********************/
/*! exports provided: Helper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Helper\", function() { return Helper; });\n/**\r\n * A class containing helping mathematical methods\r\n */\r\nclass Helper {\r\n    /**\r\n     * Get the distance between two points\r\n     *\r\n     * @param {Point} point1\r\n     * @param {Point} point2\r\n     */\r\n    static GetDistanceBetweenTwoPoint(point1, point2) {\r\n        if (point1 === null || point2 === null) {\r\n            return Infinity;\r\n        }\r\n        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\r\n    }\r\n    /**\r\n     * Get the length of the line segment\r\n     *\r\n     * @param {Segment} segment\r\n     */\r\n    static GetSegmentLength(segment) {\r\n        return Helper.GetDistanceBetweenTwoPoint(segment[0], segment[1]);\r\n    }\r\n    /**\r\n     * Get the angle between two lines\r\n     *\r\n     * @param {Segment} line1\r\n     * @param {Segment} line2\r\n     */\r\n    static GetAngleBetweenTwoLine(line1, line2) {\r\n        const A1 = line1[0].y - line1[1].y;\r\n        const A2 = line2[0].y - line2[1].y;\r\n        const B1 = line1[1].x - line1[0].x;\r\n        const B2 = line2[1].x - line2[0].x;\r\n        return Math.acos((A1 * A2 + B1 * B2) / (Math.sqrt(A1 * A1 + B1 * B1) * Math.sqrt(A2 * A2 + B2 * B2)));\r\n    }\r\n    /**\r\n     * Check for a point in a rectangle\r\n     *\r\n     * @param {Rect} rect\r\n     * @param {Point} pos\r\n     *\r\n     * @returns {Point} If the point enters the rectangle its coordinates will be returned, otherwise - null\r\n     */\r\n    static PointInRect(rect, pos) {\r\n        if (pos === null) {\r\n            return null;\r\n        }\r\n        if (pos.x >= rect.left &&\r\n            pos.x <= rect.width + rect.left &&\r\n            pos.y >= rect.top &&\r\n            pos.y <= rect.top + rect.height) {\r\n            return pos;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Transform point coordinates to a given angle\r\n     *\r\n     * @param {Point} transformedPoint - Point to rotate\r\n     * @param {Point} startPoint - Transformation reference point\r\n     * @param {number} angle - Rotation angle (in radians)\r\n     *\r\n     * @returns {Point} Point coordinates after rotation\r\n     */\r\n    static GetRotatedPoint(transformedPoint, startPoint, angle) {\r\n        return {\r\n            x: transformedPoint.x * Math.cos(angle) + transformedPoint.y * Math.sin(angle) + startPoint.x,\r\n            y: transformedPoint.y * Math.cos(angle) - transformedPoint.x * Math.sin(angle) + startPoint.y,\r\n        };\r\n    }\r\n    /**\r\n     * Limit a point \"linePoint\" to a given circle centered at point \"startPoint\" and a given radius\r\n     *\r\n     * @param {Point} startPoint - Circle center\r\n     * @param {number} radius - Circle radius\r\n     * @param {Point} limitedPoint - 小hecked point\r\n     *\r\n     * @returns {Point} If \"linePoint\" enters the circle, then its coordinates are returned.\r\n     * Else will be returned the intersection point between the line ([startPoint, linePoint]) and the circle\r\n     */\r\n    static LimitPointToCircle(startPoint, radius, limitedPoint) {\r\n        // If \"linePoint\" enters the circle, do nothing\r\n        if (Helper.GetDistanceBetweenTwoPoint(startPoint, limitedPoint) <= radius) {\r\n            return limitedPoint;\r\n        }\r\n        const a = startPoint.x;\r\n        const b = startPoint.y;\r\n        const n = limitedPoint.x;\r\n        const m = limitedPoint.y;\r\n        // Find the intersection between the line at two points: (startPoint and limitedPoint) and the circle.\r\n        let x = Math.sqrt((Math.pow(radius, 2) * Math.pow(a - n, 2)) / (Math.pow(a - n, 2) + Math.pow(b - m, 2))) + a;\r\n        if (limitedPoint.x < 0) {\r\n            x *= -1;\r\n        }\r\n        let y = ((x - a) * (b - m)) / (a - n) + b;\r\n        if (a - n + b === 0) {\r\n            y = radius;\r\n        }\r\n        return { x, y };\r\n    }\r\n    /**\r\n     * Find the intersection of two lines bounded by a rectangle \"rectBorder\"\r\n     *\r\n     * @param {Rect} rectBorder\r\n     * @param {Segment} one\r\n     * @param {Segment} two\r\n     *\r\n     * @returns {Point} The intersection point, or \"null\" if it does not exist, or it lies outside the rectangle \"rectBorder\"\r\n     */\r\n    static GetIntersectBetweenTwoSegment(rectBorder, one, two) {\r\n        return Helper.PointInRect(rectBorder, Helper.GetIntersectBeetwenTwoLine(one, two));\r\n    }\r\n    /**\r\n     * Find the intersection point of two lines\r\n     *\r\n     * @param one\r\n     * @param two\r\n     *\r\n     * @returns {Point} The intersection point, or \"null\" if it does not exist\r\n     * @throws Error if the segments are on the same line\r\n     */\r\n    static GetIntersectBeetwenTwoLine(one, two) {\r\n        const A1 = one[0].y - one[1].y;\r\n        const A2 = two[0].y - two[1].y;\r\n        const B1 = one[1].x - one[0].x;\r\n        const B2 = two[1].x - two[0].x;\r\n        const C1 = one[0].x * one[1].y - one[1].x * one[0].y;\r\n        const C2 = two[0].x * two[1].y - two[1].x * two[0].y;\r\n        const det1 = A1 * C2 - A2 * C1;\r\n        const det2 = B1 * C2 - B2 * C1;\r\n        const x = -((C1 * B2 - C2 * B1) / (A1 * B2 - A2 * B1));\r\n        const y = -((A1 * C2 - A2 * C1) / (A1 * B2 - A2 * B1));\r\n        if (isFinite(x) && isFinite(y)) {\r\n            return { x, y };\r\n        }\r\n        else {\r\n            if (Math.abs(det1 - det2) < 0.1)\r\n                throw new Error('Segment included');\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get a list of coordinates (step: 1px) between two points\r\n     *\r\n     * @param pointOne\r\n     * @param pointTwo\r\n     *\r\n     * @returns {Point[]}\r\n     */\r\n    static GetCordsFromTwoPoint(pointOne, pointTwo) {\r\n        const sizeX = Math.abs(pointOne.x - pointTwo.x);\r\n        const sizeY = Math.abs(pointOne.y - pointTwo.y);\r\n        const lengthLine = Math.max(sizeX, sizeY);\r\n        const result = [pointOne];\r\n        function getCord(c1, c2, size, length, index) {\r\n            if (c2 > c1) {\r\n                return c1 + index * (size / length);\r\n            }\r\n            else if (c2 < c1) {\r\n                return c1 - index * (size / length);\r\n            }\r\n            return c1;\r\n        }\r\n        for (let i = 1; i <= lengthLine; i += 1) {\r\n            result.push({\r\n                x: getCord(pointOne.x, pointTwo.x, sizeX, lengthLine, i),\r\n                y: getCord(pointOne.y, pointTwo.y, sizeY, lengthLine, i),\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Helper.ts?");

/***/ }),

/***/ "./src/Page/HTMLPage.ts":
/*!******************************!*\
  !*** ./src/Page/HTMLPage.ts ***!
  \******************************/
/*! exports provided: HTMLPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLPage\", function() { return HTMLPage; });\n/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page */ \"./src/Page/Page.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper */ \"./src/Helper.ts\");\n\r\n\r\n/**\r\n * Class representing a book page as a HTML Element\r\n */\r\nclass HTMLPage extends _Page__WEBPACK_IMPORTED_MODULE_0__[\"Page\"] {\r\n    constructor(render, element, density) {\r\n        super(render, density);\r\n        this.copiedElement = null;\r\n        this.temporaryCopy = null;\r\n        this.isLoad = false;\r\n        this.element = element;\r\n        this.element.classList.add('stf__item');\r\n        this.element.classList.add('--' + density);\r\n    }\r\n    newTemporaryCopy() {\r\n        if (this.nowDrawingDensity === \"hard\" /* HARD */) {\r\n            return this;\r\n        }\r\n        if (this.temporaryCopy === null) {\r\n            this.copiedElement = this.element.cloneNode(true);\r\n            this.element.parentElement.appendChild(this.copiedElement);\r\n            this.temporaryCopy = new HTMLPage(this.render, this.copiedElement, this.nowDrawingDensity);\r\n        }\r\n        return this.getTemporaryCopy();\r\n    }\r\n    getTemporaryCopy() {\r\n        return this.temporaryCopy;\r\n    }\r\n    hideTemporaryCopy() {\r\n        if (this.temporaryCopy !== null) {\r\n            this.copiedElement.remove();\r\n            this.copiedElement = null;\r\n            this.temporaryCopy = null;\r\n        }\r\n    }\r\n    draw(tempDensity) {\r\n        const density = tempDensity ? tempDensity : this.nowDrawingDensity;\r\n        const pagePos = this.render.convertToGlobal(this.state.position);\r\n        const pageWidth = this.render.getRect().pageWidth;\r\n        const pageHeight = this.render.getRect().height;\r\n        this.element.classList.remove('--simple');\r\n        const commonStyle = `\r\n            display: block;\r\n            z-index: ${this.element.style.zIndex};\r\n            left: 0;\r\n            top: 0;\r\n            width: ${pageWidth}px;\r\n            height: ${pageHeight}px;\r\n        `;\r\n        density === \"hard\" /* HARD */\r\n            ? this.drawHard(commonStyle)\r\n            : this.drawSoft(pagePos, commonStyle);\r\n    }\r\n    drawHard(commonStyle = '') {\r\n        const pos = this.render.getRect().left + this.render.getRect().width / 2;\r\n        const angle = this.state.hardDrawingAngle;\r\n        const newStyle = commonStyle +\r\n            `\r\n                backface-visibility: hidden;\r\n                -webkit-backface-visibility: hidden;\r\n                clip-path: none;\r\n                -webkit-clip-path: none;\r\n            ` +\r\n            (this.orientation === 0 /* LEFT */\r\n                ? `transform-origin: ${this.render.getRect().pageWidth}px 0; \r\n                   transform: translate3d(0, 0, 0) rotateY(${angle}deg);`\r\n                : `transform-origin: 0 0; \r\n                   transform: translate3d(${pos}px, 0, 0) rotateY(${angle}deg);`);\r\n        this.element.style.cssText = newStyle;\r\n    }\r\n    drawSoft(position, commonStyle = '') {\r\n        let polygon = 'polygon( ';\r\n        for (const p of this.state.area) {\r\n            if (p !== null) {\r\n                let g = this.render.getDirection() === 1 /* BACK */\r\n                    ? {\r\n                        x: -p.x + this.state.position.x,\r\n                        y: p.y - this.state.position.y,\r\n                    }\r\n                    : {\r\n                        x: p.x - this.state.position.x,\r\n                        y: p.y - this.state.position.y,\r\n                    };\r\n                g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: 0, y: 0 }, this.state.angle);\r\n                polygon += g.x + 'px ' + g.y + 'px, ';\r\n            }\r\n        }\r\n        polygon = polygon.slice(0, -2);\r\n        polygon += ')';\r\n        const newStyle = commonStyle +\r\n            `transform-origin: 0 0; clip-path: ${polygon}; -webkit-clip-path: ${polygon};` +\r\n            (this.render.isSafari() && this.state.angle === 0\r\n                ? `transform: translate(${position.x}px, ${position.y}px);`\r\n                : `transform: translate3d(${position.x}px, ${position.y}px, 0) rotate(${this.state.angle}rad);`);\r\n        this.element.style.cssText = newStyle;\r\n    }\r\n    simpleDraw(orient) {\r\n        const rect = this.render.getRect();\r\n        const pageWidth = rect.pageWidth;\r\n        const pageHeight = rect.height;\r\n        const x = orient === 1 /* RIGHT */ ? rect.left + rect.pageWidth : rect.left;\r\n        const y = rect.top;\r\n        this.element.classList.add('--simple');\r\n        this.element.style.cssText = `\r\n            position: absolute; \r\n            display: block; \r\n            height: ${pageHeight}px; \r\n            left: ${x}px; \r\n            top: ${y}px; \r\n            width: ${pageWidth}px; \r\n            z-index: ${this.render.getSettings().startZIndex + 1};`;\r\n    }\r\n    getElement() {\r\n        return this.element;\r\n    }\r\n    load() {\r\n        this.isLoad = true;\r\n    }\r\n    setOrientation(orientation) {\r\n        super.setOrientation(orientation);\r\n        this.element.classList.remove('--left', '--right');\r\n        this.element.classList.add(orientation === 1 /* RIGHT */ ? '--right' : '--left');\r\n    }\r\n    setDrawingDensity(density) {\r\n        this.element.classList.remove('--soft', '--hard');\r\n        this.element.classList.add('--' + density);\r\n        super.setDrawingDensity(density);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Page/HTMLPage.ts?");

/***/ }),

/***/ "./src/Page/ImagePage.ts":
/*!*******************************!*\
  !*** ./src/Page/ImagePage.ts ***!
  \*******************************/
/*! exports provided: ImagePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImagePage\", function() { return ImagePage; });\n/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page */ \"./src/Page/Page.ts\");\n\r\n/**\r\n * Class representing a book page as an image on Canvas\r\n */\r\nclass ImagePage extends _Page__WEBPACK_IMPORTED_MODULE_0__[\"Page\"] {\r\n    constructor(render, href, density) {\r\n        super(render, density);\r\n        this.image = null;\r\n        this.isLoad = false;\r\n        this.loadingAngle = 0;\r\n        this.image = new Image();\r\n        this.image.src = href;\r\n    }\r\n    draw(tempDensity) {\r\n        const ctx = this.render.getContext();\r\n        const pagePos = this.render.convertToGlobal(this.state.position);\r\n        const pageWidth = this.render.getRect().pageWidth;\r\n        const pageHeight = this.render.getRect().height;\r\n        ctx.save();\r\n        ctx.translate(pagePos.x, pagePos.y);\r\n        ctx.beginPath();\r\n        for (let p of this.state.area) {\r\n            if (p !== null) {\r\n                p = this.render.convertToGlobal(p);\r\n                ctx.lineTo(p.x - pagePos.x, p.y - pagePos.y);\r\n            }\r\n        }\r\n        ctx.rotate(this.state.angle);\r\n        ctx.clip();\r\n        if (!this.isLoad) {\r\n            this.drawLoader(ctx, { x: 0, y: 0 }, pageWidth, pageHeight);\r\n        }\r\n        else {\r\n            ctx.drawImage(this.image, 0, 0, pageWidth, pageHeight);\r\n        }\r\n        ctx.restore();\r\n    }\r\n    simpleDraw(orient) {\r\n        const rect = this.render.getRect();\r\n        const ctx = this.render.getContext();\r\n        const pageWidth = rect.pageWidth;\r\n        const pageHeight = rect.height;\r\n        const x = orient === 1 /* RIGHT */ ? rect.left + rect.pageWidth : rect.left;\r\n        const y = rect.top;\r\n        if (!this.isLoad) {\r\n            this.drawLoader(ctx, { x, y }, pageWidth, pageHeight);\r\n        }\r\n        else {\r\n            ctx.drawImage(this.image, x, y, pageWidth, pageHeight);\r\n        }\r\n    }\r\n    drawLoader(ctx, shiftPos, pageWidth, pageHeight) {\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = 'rgb(200, 200, 200)';\r\n        ctx.fillStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 1;\r\n        ctx.rect(shiftPos.x + 1, shiftPos.y + 1, pageWidth - 1, pageHeight - 1);\r\n        ctx.stroke();\r\n        ctx.fill();\r\n        const middlePoint = {\r\n            x: shiftPos.x + pageWidth / 2,\r\n            y: shiftPos.y + pageHeight / 2,\r\n        };\r\n        ctx.beginPath();\r\n        ctx.lineWidth = 10;\r\n        ctx.arc(middlePoint.x, middlePoint.y, 20, this.loadingAngle, (3 * Math.PI) / 2 + this.loadingAngle);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n        this.loadingAngle += 0.07;\r\n        if (this.loadingAngle >= 2 * Math.PI) {\r\n            this.loadingAngle = 0;\r\n        }\r\n    }\r\n    load() {\r\n        if (!this.isLoad)\r\n            this.image.onload = () => {\r\n                this.isLoad = true;\r\n            };\r\n    }\r\n    newTemporaryCopy() {\r\n        return this;\r\n    }\r\n    getTemporaryCopy() {\r\n        return this;\r\n    }\r\n    hideTemporaryCopy() {\r\n        return;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Page/ImagePage.ts?");

/***/ }),

/***/ "./src/Page/Page.ts":
/*!**************************!*\
  !*** ./src/Page/Page.ts ***!
  \**************************/
/*! exports provided: Page */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Page\", function() { return Page; });\n/**\r\n * Class representing a book page\r\n */\r\nclass Page {\r\n    constructor(render, density) {\r\n        this.state = {\r\n            angle: 0,\r\n            area: [],\r\n            position: { x: 0, y: 0 },\r\n            hardAngle: 0,\r\n            hardDrawingAngle: 0,\r\n        };\r\n        this.createdDensity = density;\r\n        this.nowDrawingDensity = this.createdDensity;\r\n        this.render = render;\r\n    }\r\n    /**\r\n     * Set a constant page density\r\n     *\r\n     * @param {PageDensity} density\r\n     */\r\n    setDensity(density) {\r\n        this.createdDensity = density;\r\n        this.nowDrawingDensity = density;\r\n    }\r\n    /**\r\n     * Set temp page density to next render\r\n     *\r\n     * @param {PageDensity}  density\r\n     */\r\n    setDrawingDensity(density) {\r\n        this.nowDrawingDensity = density;\r\n    }\r\n    /**\r\n     * Set page position\r\n     *\r\n     * @param {Point} pagePos\r\n     */\r\n    setPosition(pagePos) {\r\n        this.state.position = pagePos;\r\n    }\r\n    /**\r\n     * Set page angle\r\n     *\r\n     * @param {number} angle\r\n     */\r\n    setAngle(angle) {\r\n        this.state.angle = angle;\r\n    }\r\n    /**\r\n     * Set page crop area\r\n     *\r\n     * @param {Point[]} area\r\n     */\r\n    setArea(area) {\r\n        this.state.area = area;\r\n    }\r\n    /**\r\n     * Rotate angle for hard pages to next render\r\n     *\r\n     * @param {number} angle\r\n     */\r\n    setHardDrawingAngle(angle) {\r\n        this.state.hardDrawingAngle = angle;\r\n    }\r\n    /**\r\n     * Rotate angle for hard pages\r\n     *\r\n     * @param {number} angle\r\n     */\r\n    setHardAngle(angle) {\r\n        this.state.hardAngle = angle;\r\n        this.state.hardDrawingAngle = angle;\r\n    }\r\n    /**\r\n     * Set page orientation\r\n     *\r\n     * @param {PageOrientation} orientation\r\n     */\r\n    setOrientation(orientation) {\r\n        this.orientation = orientation;\r\n    }\r\n    /**\r\n     * Get temp page density\r\n     */\r\n    getDrawingDensity() {\r\n        return this.nowDrawingDensity;\r\n    }\r\n    /**\r\n     * Get a constant page density\r\n     */\r\n    getDensity() {\r\n        return this.createdDensity;\r\n    }\r\n    /**\r\n     * Get rotate angle for hard pages\r\n     */\r\n    getHardAngle() {\r\n        return this.state.hardAngle;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Page/Page.ts?");

/***/ }),

/***/ "./src/PageFlip.ts":
/*!*************************!*\
  !*** ./src/PageFlip.ts ***!
  \*************************/
/*! exports provided: PageFlip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageFlip\", function() { return PageFlip; });\n/* harmony import */ var _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection/ImagePageCollection */ \"./src/Collection/ImagePageCollection.ts\");\n/* harmony import */ var _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection/HTMLPageCollection */ \"./src/Collection/HTMLPageCollection.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Flip/Flip */ \"./src/Flip/Flip.ts\");\n/* harmony import */ var _Render_CanvasRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Render/CanvasRender */ \"./src/Render/CanvasRender.ts\");\n/* harmony import */ var _UI_HTMLUI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UI/HTMLUI */ \"./src/UI/HTMLUI.ts\");\n/* harmony import */ var _UI_CanvasUI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UI/CanvasUI */ \"./src/UI/CanvasUI.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Helper */ \"./src/Helper.ts\");\n/* harmony import */ var _Event_EventObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Event/EventObject */ \"./src/Event/EventObject.ts\");\n/* harmony import */ var _Render_HTMLRender__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Render/HTMLRender */ \"./src/Render/HTMLRender.ts\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Settings */ \"./src/Settings.ts\");\n/* harmony import */ var _Style_stPageFlip_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Style/stPageFlip.css */ \"./src/Style/stPageFlip.css\");\n/* harmony import */ var _Style_stPageFlip_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_Style_stPageFlip_css__WEBPACK_IMPORTED_MODULE_10__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Class representing a main PageFlip object\r\n *\r\n * @extends EventObject\r\n */\r\nclass PageFlip extends _Event_EventObject__WEBPACK_IMPORTED_MODULE_7__[\"EventObject\"] {\r\n    /**\r\n     * Create a new PageFlip instance\r\n     *\r\n     * @constructor\r\n     * @param {HTMLElement} inBlock - Root HTML Element\r\n     * @param {Object} setting - Configuration object\r\n     */\r\n    constructor(inBlock, setting) {\r\n        super();\r\n        this.isUserTouch = false;\r\n        this.isUserMove = false;\r\n        this.setting = null;\r\n        this.pages = null;\r\n        this.setting = new _Settings__WEBPACK_IMPORTED_MODULE_9__[\"Settings\"]().getSettings(setting);\r\n        this.block = inBlock;\r\n    }\r\n    /**\r\n     * Destructor. Remove a root HTML element and all event handlers\r\n     */\r\n    destroy() {\r\n        this.ui.destroy();\r\n        this.block.remove();\r\n    }\r\n    /**\r\n     * Update the render area. Re-show current page.\r\n     */\r\n    update() {\r\n        this.render.update();\r\n        this.pages.show();\r\n    }\r\n    /**\r\n     * Load pages from images on the Canvas mode\r\n     *\r\n     * @param {string[]} imagesHref - List of paths to images\r\n     */\r\n    loadFromImages(imagesHref) {\r\n        this.ui = new _UI_CanvasUI__WEBPACK_IMPORTED_MODULE_5__[\"CanvasUI\"](this.block, this, this.setting);\r\n        const canvas = this.ui.getCanvas();\r\n        this.render = new _Render_CanvasRender__WEBPACK_IMPORTED_MODULE_3__[\"CanvasRender\"](this, this.setting, canvas);\r\n        this.flipController = new _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"Flip\"](this.render, this);\r\n        this.pages = new _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__[\"ImagePageCollection\"](this, this.render, imagesHref);\r\n        this.pages.load();\r\n        this.render.start();\r\n        this.pages.show(this.setting.startPage);\r\n        // safari fix\r\n        setTimeout(() => {\r\n            this.ui.update();\r\n            this.trigger('init', this, {\r\n                page: this.setting.startPage,\r\n                mode: this.render.getOrientation(),\r\n            });\r\n        }, 1);\r\n    }\r\n    /**\r\n     * Load pages from HTML elements on the HTML mode\r\n     *\r\n     * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\r\n     */\r\n    loadFromHTML(items) {\r\n        this.ui = new _UI_HTMLUI__WEBPACK_IMPORTED_MODULE_4__[\"HTMLUI\"](this.block, this, this.setting, items);\r\n        this.render = new _Render_HTMLRender__WEBPACK_IMPORTED_MODULE_8__[\"HTMLRender\"](this, this.setting, this.ui.getDistElement());\r\n        this.flipController = new _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"Flip\"](this.render, this);\r\n        this.pages = new _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__[\"HTMLPageCollection\"](this, this.render, this.ui.getDistElement(), items);\r\n        this.pages.load();\r\n        this.render.start();\r\n        this.pages.show(this.setting.startPage);\r\n        // safari fix\r\n        setTimeout(() => {\r\n            this.ui.update();\r\n            this.trigger('init', this, {\r\n                page: this.setting.startPage,\r\n                mode: this.render.getOrientation(),\r\n            });\r\n        }, 1);\r\n    }\r\n    /**\r\n     * Update current pages from images\r\n     *\r\n     * @param {string[]} imagesHref - List of paths to images\r\n     */\r\n    updateFromImages(imagesHref) {\r\n        const current = this.pages.getCurrentPageIndex();\r\n        this.pages.destroy();\r\n        this.pages = new _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__[\"ImagePageCollection\"](this, this.render, imagesHref);\r\n        this.pages.load();\r\n        this.pages.show(current);\r\n        this.trigger('update', this, {\r\n            page: current,\r\n            mode: this.render.getOrientation(),\r\n        });\r\n    }\r\n    /**\r\n     * Update current pages from HTML\r\n     *\r\n     * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\r\n     */\r\n    updateFromHtml(items) {\r\n        const current = this.pages.getCurrentPageIndex();\r\n        this.pages.destroy();\r\n        this.pages = new _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__[\"HTMLPageCollection\"](this, this.render, this.ui.getDistElement(), items);\r\n        this.pages.load();\r\n        this.ui.updateItems(items);\r\n        this.pages.show(current);\r\n        this.trigger('update', this, {\r\n            page: current,\r\n            mode: this.render.getOrientation(),\r\n        });\r\n    }\r\n    /**\r\n     * Turn to the previous page (without animation)\r\n     */\r\n    turnToPrevPage() {\r\n        this.pages.showPrev();\r\n    }\r\n    /**\r\n     * Turn to the next page (without animation)\r\n     */\r\n    turnToNextPage() {\r\n        this.pages.showNext();\r\n    }\r\n    /**\r\n     * Turn to the specified page number (without animation)\r\n     *\r\n     * @param {number} page - New page number\r\n     */\r\n    turnToPage(page) {\r\n        this.pages.show(page);\r\n    }\r\n    /**\r\n     * Turn to the next page (with animation)\r\n     *\r\n     * @param {FlipCorner} corner - Active page corner when turning\r\n     */\r\n    flipNext(corner = \"top\" /* TOP */) {\r\n        this.flipController.flipNext(corner);\r\n    }\r\n    /**\r\n     * Turn to the prev page (with animation)\r\n     *\r\n     * @param {FlipCorner} corner - Active page corner when turning\r\n     */\r\n    flipPrev(corner = \"top\" /* TOP */) {\r\n        this.flipController.flipPrev(corner);\r\n    }\r\n    /**\r\n     * Turn to the specified page number (with animation)\r\n     *\r\n     * @param {number} page - New page number\r\n     * @param {FlipCorner} corner - Active page corner when turning\r\n     */\r\n    flip(page, corner = \"top\" /* TOP */) {\r\n        this.flipController.flipToPage(page, corner);\r\n    }\r\n    /**\r\n     * Call a state change event trigger\r\n     *\r\n     * @param {FlippingState} newState - New  state of the object\r\n     */\r\n    updateState(newState) {\r\n        this.trigger('changeState', this, newState);\r\n    }\r\n    /**\r\n     * Call a page number change event trigger\r\n     *\r\n     * @param {number} newPage - New page Number\r\n     */\r\n    updatePageIndex(newPage) {\r\n        this.trigger('flip', this, newPage);\r\n    }\r\n    /**\r\n     * Call a page orientation change event trigger. Update UI and rendering area\r\n     *\r\n     * @param {Orientation} newOrientation - New page orientation (portrait, landscape)\r\n     */\r\n    updateOrientation(newOrientation) {\r\n        this.ui.setOrientationStyle(newOrientation);\r\n        this.update();\r\n        this.trigger('changeOrientation', this, newOrientation);\r\n    }\r\n    /**\r\n     * Get the total number of pages in a book\r\n     *\r\n     * @returns {number}\r\n     */\r\n    getPageCount() {\r\n        return this.pages.getPageCount();\r\n    }\r\n    /**\r\n     * Get the index of the current page in the page list (starts at 0)\r\n     *\r\n     * @returns {number}\r\n     */\r\n    getCurrentPageIndex() {\r\n        return this.pages.getCurrentPageIndex();\r\n    }\r\n    /**\r\n     * Get page from collection by number\r\n     *\r\n     * @param {number} pageIndex\r\n     * @returns {Page}\r\n     */\r\n    getPage(pageIndex) {\r\n        return this.pages.getPage(pageIndex);\r\n    }\r\n    /**\r\n     * Get the current rendering object\r\n     *\r\n     * @returns {Render}\r\n     */\r\n    getRender() {\r\n        return this.render;\r\n    }\r\n    /**\r\n     * Get current object responsible for flipping\r\n     *\r\n     * @returns {Flip}\r\n     */\r\n    getFlipController() {\r\n        return this.flipController;\r\n    }\r\n    /**\r\n     * Get current page orientation\r\n     *\r\n     * @returns {Orientation} 小urrent orientation: portrait or landscape\r\n     */\r\n    getOrientation() {\r\n        return this.render.getOrientation();\r\n    }\r\n    /**\r\n     * Get current book sizes and position\r\n     *\r\n     * @returns {PageRect}\r\n     */\r\n    getBoundsRect() {\r\n        return this.render.getRect();\r\n    }\r\n    /**\r\n     * Get configuration object\r\n     *\r\n     * @returns {FlipSetting}\r\n     */\r\n    getSettings() {\r\n        return this.setting;\r\n    }\r\n    /**\r\n     * Get UI object\r\n     *\r\n     * @returns {UI}\r\n     */\r\n    getUI() {\r\n        return this.ui;\r\n    }\r\n    /**\r\n     * Get current flipping state\r\n     *\r\n     * @returns {FlippingState}\r\n     */\r\n    getState() {\r\n        return this.flipController.getState();\r\n    }\r\n    /**\r\n     * Get page collection\r\n     *\r\n     * @returns {PageCollection}\r\n     */\r\n    getPageCollection() {\r\n        return this.pages;\r\n    }\r\n    /**\r\n     * Start page turning. Called when a user clicks or touches\r\n     *\r\n     * @param {Point} pos - Touch position in coordinates relative to the book\r\n     */\r\n    startUserTouch(pos) {\r\n        this.mousePosition = pos; // Save touch position\r\n        this.isUserTouch = true;\r\n        this.isUserMove = false;\r\n    }\r\n    /**\r\n     * Called when a finger / mouse moves\r\n     *\r\n     * @param {Point} pos - Touch position in coordinates relative to the book\r\n     * @param {boolean} isTouch - True if there was a touch event, not a mouse click\r\n     */\r\n    userMove(pos, isTouch) {\r\n        if (!this.isUserTouch && !isTouch && this.setting.showPageCorners) {\r\n            this.flipController.showCorner(pos); // fold Page Corner\r\n        }\r\n        else if (this.isUserTouch) {\r\n            if (_Helper__WEBPACK_IMPORTED_MODULE_6__[\"Helper\"].GetDistanceBetweenTwoPoint(this.mousePosition, pos) > 5) {\r\n                this.isUserMove = true;\r\n                this.flipController.fold(pos);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 小alled when the user has stopped touching\r\n     *\r\n     * @param {Point} pos - Touch end position in coordinates relative to the book\r\n     * @param {boolean} isSwipe - true if there was a mobile swipe event\r\n     */\r\n    userStop(pos, isSwipe = false) {\r\n        if (this.isUserTouch) {\r\n            this.isUserTouch = false;\r\n            if (!isSwipe) {\r\n                if (!this.isUserMove)\r\n                    this.flipController.flip(pos);\r\n                else\r\n                    this.flipController.stopMove();\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/PageFlip.ts?");

/***/ }),

/***/ "./src/Render/CanvasRender.ts":
/*!************************************!*\
  !*** ./src/Render/CanvasRender.ts ***!
  \************************************/
/*! exports provided: CanvasRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasRender\", function() { return CanvasRender; });\n/* harmony import */ var _Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render */ \"./src/Render/Render.ts\");\n\r\n/**\r\n * Class responsible for rendering the Canvas book\r\n */\r\nclass CanvasRender extends _Render__WEBPACK_IMPORTED_MODULE_0__[\"Render\"] {\r\n    constructor(app, setting, inCanvas) {\r\n        super(app, setting);\r\n        this.canvas = inCanvas;\r\n        this.ctx = inCanvas.getContext('2d');\r\n    }\r\n    getContext() {\r\n        return this.ctx;\r\n    }\r\n    drawFrame() {\r\n        this.clear();\r\n        if (this.orientation !== \"portrait\" /* PORTRAIT */)\r\n            if (this.leftPage != null)\r\n                this.leftPage.simpleDraw(0 /* LEFT */);\r\n        if (this.rightPage != null)\r\n            this.rightPage.simpleDraw(1 /* RIGHT */);\r\n        if (this.bottomPage != null)\r\n            this.bottomPage.draw();\r\n        this.drawBookShadow();\r\n        if (this.flippingPage != null)\r\n            this.flippingPage.draw();\r\n        if (this.shadow != null) {\r\n            this.drawOuterShadow();\r\n            this.drawInnerShadow();\r\n        }\r\n        const rect = this.getRect();\r\n        if (this.orientation === \"portrait\" /* PORTRAIT */) {\r\n            this.ctx.beginPath();\r\n            this.ctx.rect(rect.left + rect.pageWidth, rect.top, rect.width, rect.height);\r\n            this.ctx.clip();\r\n        }\r\n    }\r\n    drawBookShadow() {\r\n        const rect = this.getRect();\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        const shadowSize = rect.width / 20;\r\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\r\n        const shadowPos = { x: rect.left + rect.width / 2 - shadowSize / 2, y: 0 };\r\n        this.ctx.translate(shadowPos.x, shadowPos.y);\r\n        const outerGradient = this.ctx.createLinearGradient(0, 0, shadowSize, 0);\r\n        outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\r\n        outerGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.2)');\r\n        outerGradient.addColorStop(0.49, 'rgba(0, 0, 0, 0.1)');\r\n        outerGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');\r\n        outerGradient.addColorStop(0.51, 'rgba(0, 0, 0, 0.4)');\r\n        outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n        this.ctx.clip();\r\n        this.ctx.fillStyle = outerGradient;\r\n        this.ctx.fillRect(0, 0, shadowSize, rect.height * 2);\r\n        this.ctx.restore();\r\n    }\r\n    drawOuterShadow() {\r\n        const rect = this.getRect();\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\r\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\r\n        this.ctx.translate(shadowPos.x, shadowPos.y);\r\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\r\n        const outerGradient = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);\r\n        if (this.shadow.direction === 0 /* FORWARD */) {\r\n            this.ctx.translate(0, -100);\r\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n        }\r\n        else {\r\n            this.ctx.translate(-this.shadow.width, -100);\r\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\r\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n        }\r\n        this.ctx.clip();\r\n        this.ctx.fillStyle = outerGradient;\r\n        this.ctx.fillRect(0, 0, this.shadow.width, rect.height * 2);\r\n        this.ctx.restore();\r\n    }\r\n    drawInnerShadow() {\r\n        const rect = this.getRect();\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\r\n        const pageRect = this.convertRectToGlobal(this.pageRect);\r\n        this.ctx.moveTo(pageRect.topLeft.x, pageRect.topLeft.y);\r\n        this.ctx.lineTo(pageRect.topRight.x, pageRect.topRight.y);\r\n        this.ctx.lineTo(pageRect.bottomRight.x, pageRect.bottomRight.y);\r\n        this.ctx.lineTo(pageRect.bottomLeft.x, pageRect.bottomLeft.y);\r\n        this.ctx.translate(shadowPos.x, shadowPos.y);\r\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\r\n        const isw = (this.shadow.width * 3) / 4;\r\n        const innerGradient = this.ctx.createLinearGradient(0, 0, isw, 0);\r\n        if (this.shadow.direction === 0 /* FORWARD */) {\r\n            this.ctx.translate(-isw, -100);\r\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.05)');\r\n            innerGradient.addColorStop(0.7, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\r\n        }\r\n        else {\r\n            this.ctx.translate(0, -100);\r\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');\r\n            innerGradient.addColorStop(0.3, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n        }\r\n        this.ctx.clip();\r\n        this.ctx.fillStyle = innerGradient;\r\n        this.ctx.fillRect(0, 0, isw, rect.height * 2);\r\n        this.ctx.restore();\r\n    }\r\n    clear() {\r\n        this.ctx.fillStyle = 'white';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Render/CanvasRender.ts?");

/***/ }),

/***/ "./src/Render/HTMLRender.ts":
/*!**********************************!*\
  !*** ./src/Render/HTMLRender.ts ***!
  \**********************************/
/*! exports provided: HTMLRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLRender\", function() { return HTMLRender; });\n/* harmony import */ var _Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render */ \"./src/Render/Render.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper */ \"./src/Helper.ts\");\n\r\n\r\n/**\r\n * Class responsible for rendering the HTML book\r\n */\r\nclass HTMLRender extends _Render__WEBPACK_IMPORTED_MODULE_0__[\"Render\"] {\r\n    /**\r\n     * @constructor\r\n     *\r\n     * @param {PageFlip} app - PageFlip object\r\n     * @param {FlipSetting} setting - Configuration object\r\n     * @param {HTMLElement} element - Parent HTML Element\r\n     */\r\n    constructor(app, setting, element) {\r\n        super(app, setting);\r\n        this.outerShadow = null;\r\n        this.innerShadow = null;\r\n        this.hardShadow = null;\r\n        this.hardInnerShadow = null;\r\n        this.element = element;\r\n        this.createShadows();\r\n    }\r\n    createShadows() {\r\n        this.element.insertAdjacentHTML('beforeend', `<div class=\"stf__outerShadow\"></div>\r\n             <div class=\"stf__innerShadow\"></div>\r\n             <div class=\"stf__hardShadow\"></div>\r\n             <div class=\"stf__hardInnerShadow\"></div>`);\r\n        this.outerShadow = this.element.querySelector('.stf__outerShadow');\r\n        this.innerShadow = this.element.querySelector('.stf__innerShadow');\r\n        this.hardShadow = this.element.querySelector('.stf__hardShadow');\r\n        this.hardInnerShadow = this.element.querySelector('.stf__hardInnerShadow');\r\n    }\r\n    clearShadow() {\r\n        super.clearShadow();\r\n        this.outerShadow.style.cssText = 'display: none';\r\n        this.innerShadow.style.cssText = 'display: none';\r\n        this.hardShadow.style.cssText = 'display: none';\r\n        this.hardInnerShadow.style.cssText = 'display: none';\r\n    }\r\n    /**\r\n     * Draw inner shadow to the hard page\r\n     */\r\n    drawHardInnerShadow() {\r\n        const rect = this.getRect();\r\n        const progress = this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\r\n        let innerShadowSize = ((100 - progress) * (2.5 * rect.pageWidth)) / 100 + 20;\r\n        if (innerShadowSize > rect.pageWidth)\r\n            innerShadowSize = rect.pageWidth;\r\n        let newStyle = `\r\n            display: block;\r\n            z-index: ${(this.getSettings().startZIndex + 5).toString(10)};\r\n            width: ${innerShadowSize}px;\r\n            height: ${rect.height}px;\r\n            background: linear-gradient(to right,\r\n                rgba(0, 0, 0, ${(this.shadow.opacity * progress) / 100}) 5%,\r\n                rgba(0, 0, 0, 0) 100%);\r\n            left: ${rect.left + rect.width / 2}px;\r\n            transform-origin: 0 0;\r\n        `;\r\n        newStyle +=\r\n            (this.getDirection() === 0 /* FORWARD */ && this.shadow.progress > 100) ||\r\n                (this.getDirection() === 1 /* BACK */ && this.shadow.progress <= 100)\r\n                ? `transform: translate3d(0, 0, 0);`\r\n                : `transform: translate3d(0, 0, 0) rotateY(180deg);`;\r\n        this.hardInnerShadow.style.cssText = newStyle;\r\n    }\r\n    /**\r\n     * Draw outer shadow to the hard page\r\n     */\r\n    drawHardOuterShadow() {\r\n        const rect = this.getRect();\r\n        const progress = this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\r\n        let shadowSize = ((100 - progress) * (2.5 * rect.pageWidth)) / 100 + 20;\r\n        if (shadowSize > rect.pageWidth)\r\n            shadowSize = rect.pageWidth;\r\n        let newStyle = `\r\n            display: block;\r\n            z-index: ${(this.getSettings().startZIndex + 4).toString(10)};\r\n            width: ${shadowSize}px;\r\n            height: ${rect.height}px;\r\n            background: linear-gradient(to left, rgba(0, 0, 0, ${this.shadow.opacity}) 5%, rgba(0, 0, 0, 0) 100%);\r\n            left: ${rect.left + rect.width / 2}px;\r\n            transform-origin: 0 0;\r\n        `;\r\n        newStyle +=\r\n            (this.getDirection() === 0 /* FORWARD */ && this.shadow.progress > 100) ||\r\n                (this.getDirection() === 1 /* BACK */ && this.shadow.progress <= 100)\r\n                ? `transform: translate3d(0, 0, 0) rotateY(180deg);`\r\n                : `transform: translate3d(0, 0, 0);`;\r\n        this.hardShadow.style.cssText = newStyle;\r\n    }\r\n    /**\r\n     * Draw inner shadow to the soft page\r\n     */\r\n    drawInnerShadow() {\r\n        const rect = this.getRect();\r\n        const innerShadowSize = (this.shadow.width * 3) / 4;\r\n        const shadowTranslate = this.getDirection() === 0 /* FORWARD */ ? innerShadowSize : 0;\r\n        const shadowDirection = this.getDirection() === 0 /* FORWARD */ ? 'to left' : 'to right';\r\n        const shadowPos = this.convertToGlobal(this.shadow.pos);\r\n        const angle = this.shadow.angle + (3 * Math.PI) / 2;\r\n        const clip = [\r\n            this.pageRect.topLeft,\r\n            this.pageRect.topRight,\r\n            this.pageRect.bottomRight,\r\n            this.pageRect.bottomLeft,\r\n        ];\r\n        let polygon = 'polygon( ';\r\n        for (const p of clip) {\r\n            let g = this.getDirection() === 1 /* BACK */\r\n                ? {\r\n                    x: -p.x + this.shadow.pos.x,\r\n                    y: p.y - this.shadow.pos.y,\r\n                }\r\n                : {\r\n                    x: p.x - this.shadow.pos.x,\r\n                    y: p.y - this.shadow.pos.y,\r\n                };\r\n            g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\r\n            polygon += g.x + 'px ' + g.y + 'px, ';\r\n        }\r\n        polygon = polygon.slice(0, -2);\r\n        polygon += ')';\r\n        const newStyle = `\r\n            display: block;\r\n            z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\r\n            width: ${innerShadowSize}px;\r\n            height: ${rect.height * 2}px;\r\n            background: linear-gradient(${shadowDirection},\r\n                rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\r\n                rgba(0, 0, 0, 0.05) 15%,\r\n                rgba(0, 0, 0, ${this.shadow.opacity}) 35%,\r\n                rgba(0, 0, 0, 0) 100%);\r\n            transform-origin: ${shadowTranslate}px 100px;\r\n            transform: translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100}px, 0) rotate(${angle}rad);\r\n            clip-path: ${polygon};\r\n            -webkit-clip-path: ${polygon};\r\n        `;\r\n        this.innerShadow.style.cssText = newStyle;\r\n    }\r\n    /**\r\n     * Draw outer shadow to the soft page\r\n     */\r\n    drawOuterShadow() {\r\n        const rect = this.getRect();\r\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\r\n        const angle = this.shadow.angle + (3 * Math.PI) / 2;\r\n        const shadowTranslate = this.getDirection() === 1 /* BACK */ ? this.shadow.width : 0;\r\n        const shadowDirection = this.getDirection() === 0 /* FORWARD */ ? 'to right' : 'to left';\r\n        const clip = [\r\n            { x: 0, y: 0 },\r\n            { x: rect.pageWidth, y: 0 },\r\n            { x: rect.pageWidth, y: rect.height },\r\n            { x: 0, y: rect.height },\r\n        ];\r\n        let polygon = 'polygon( ';\r\n        for (const p of clip) {\r\n            if (p !== null) {\r\n                let g = this.getDirection() === 1 /* BACK */\r\n                    ? {\r\n                        x: -p.x + this.shadow.pos.x,\r\n                        y: p.y - this.shadow.pos.y,\r\n                    }\r\n                    : {\r\n                        x: p.x - this.shadow.pos.x,\r\n                        y: p.y - this.shadow.pos.y,\r\n                    };\r\n                g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\r\n                polygon += g.x + 'px ' + g.y + 'px, ';\r\n            }\r\n        }\r\n        polygon = polygon.slice(0, -2);\r\n        polygon += ')';\r\n        const newStyle = `\r\n            display: block;\r\n            z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\r\n            width: ${this.shadow.width}px;\r\n            height: ${rect.height * 2}px;\r\n            background: linear-gradient(${shadowDirection}, rgba(0, 0, 0, ${this.shadow.opacity}), rgba(0, 0, 0, 0));\r\n            transform-origin: ${shadowTranslate}px 100px;\r\n            transform: translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100}px, 0) rotate(${angle}rad);\r\n            clip-path: ${polygon};\r\n            -webkit-clip-path: ${polygon};\r\n        `;\r\n        this.outerShadow.style.cssText = newStyle;\r\n    }\r\n    /**\r\n     * Draw left static page\r\n     */\r\n    drawLeftPage() {\r\n        if (this.orientation === \"portrait\" /* PORTRAIT */ || this.leftPage === null)\r\n            return;\r\n        if (this.direction === 1 /* BACK */ &&\r\n            this.flippingPage !== null &&\r\n            this.flippingPage.getDrawingDensity() === \"hard\" /* HARD */) {\r\n            this.leftPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10);\r\n            this.leftPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\r\n            this.leftPage.draw(this.flippingPage.getDrawingDensity());\r\n        }\r\n        else {\r\n            this.leftPage.simpleDraw(0 /* LEFT */);\r\n        }\r\n    }\r\n    /**\r\n     * Draw right static page\r\n     */\r\n    drawRightPage() {\r\n        if (this.rightPage === null)\r\n            return;\r\n        if (this.direction === 0 /* FORWARD */ &&\r\n            this.flippingPage !== null &&\r\n            this.flippingPage.getDrawingDensity() === \"hard\" /* HARD */) {\r\n            this.rightPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10);\r\n            this.rightPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\r\n            this.rightPage.draw(this.flippingPage.getDrawingDensity());\r\n        }\r\n        else {\r\n            this.rightPage.simpleDraw(1 /* RIGHT */);\r\n        }\r\n    }\r\n    /**\r\n     * Draw the next page at the time of flipping\r\n     */\r\n    drawBottomPage() {\r\n        if (this.bottomPage === null)\r\n            return;\r\n        const tempDensity = this.flippingPage != null ? this.flippingPage.getDrawingDensity() : null;\r\n        if (!(this.orientation === \"portrait\" /* PORTRAIT */ && this.direction === 1 /* BACK */)) {\r\n            this.bottomPage.getElement().style.zIndex = (this.getSettings().startZIndex + 3).toString(10);\r\n            this.bottomPage.draw(tempDensity);\r\n        }\r\n    }\r\n    drawFrame() {\r\n        this.clear();\r\n        this.drawLeftPage();\r\n        this.drawRightPage();\r\n        this.drawBottomPage();\r\n        if (this.flippingPage != null) {\r\n            this.flippingPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10);\r\n            this.flippingPage.draw();\r\n        }\r\n        if (this.shadow != null && this.flippingPage !== null) {\r\n            if (this.flippingPage.getDrawingDensity() === \"soft\" /* SOFT */) {\r\n                this.drawOuterShadow();\r\n                this.drawInnerShadow();\r\n            }\r\n            else {\r\n                this.drawHardOuterShadow();\r\n                this.drawHardInnerShadow();\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        for (const page of this.app.getPageCollection().getPages()) {\r\n            if (page !== this.leftPage &&\r\n                page !== this.rightPage &&\r\n                page !== this.flippingPage &&\r\n                page !== this.bottomPage) {\r\n                page.getElement().style.cssText = 'display: none';\r\n            }\r\n            if (page.getTemporaryCopy() !== this.flippingPage) {\r\n                page.hideTemporaryCopy();\r\n            }\r\n        }\r\n    }\r\n    update() {\r\n        super.update();\r\n        if (this.rightPage !== null) {\r\n            this.rightPage.setOrientation(1 /* RIGHT */);\r\n        }\r\n        if (this.leftPage !== null) {\r\n            this.leftPage.setOrientation(0 /* LEFT */);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Render/HTMLRender.ts?");

/***/ }),

/***/ "./src/Render/Render.ts":
/*!******************************!*\
  !*** ./src/Render/Render.ts ***!
  \******************************/
/*! exports provided: Render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Render\", function() { return Render; });\n/**\r\n * Class responsible for rendering the book\r\n */\r\nclass Render {\r\n    constructor(app, setting) {\r\n        /** Left static book page */\r\n        this.leftPage = null;\r\n        /** Right static book page */\r\n        this.rightPage = null;\r\n        /** Page currently flipping */\r\n        this.flippingPage = null;\r\n        /** Next page at the time of flipping */\r\n        this.bottomPage = null;\r\n        /** Current flipping direction */\r\n        this.direction = null;\r\n        /** Current book orientation */\r\n        this.orientation = null;\r\n        /** 小urrent state of the shadows */\r\n        this.shadow = null;\r\n        /** 小urrent animation process */\r\n        this.animation = null;\r\n        /** Page borders while flipping */\r\n        this.pageRect = null;\r\n        /** Current book area */\r\n        this.boundsRect = null;\r\n        /** Timer started from start of rendering */\r\n        this.timer = 0;\r\n        /**\r\n         * Safari browser definitions for resolving a bug with a css property clip-area\r\n         *\r\n         * https://bugs.webkit.org/show_bug.cgi?id=126207\r\n         */\r\n        this.safari = false;\r\n        this.setting = setting;\r\n        this.app = app;\r\n        // detect safari\r\n        const regex = new RegExp('Version\\\\/[\\\\d\\\\.]+.*Safari/');\r\n        this.safari = regex.exec(window.navigator.userAgent) !== null;\r\n    }\r\n    /**\r\n     * Executed when requestAnimationFrame is called. Performs the current animation process and call drawFrame()\r\n     *\r\n     * @param timer\r\n     */\r\n    render(timer) {\r\n        if (this.animation !== null) {\r\n            // Find current frame of animation\r\n            const frameIndex = Math.round((timer - this.animation.startedAt) / this.animation.durationFrame);\r\n            if (frameIndex < this.animation.frames.length) {\r\n                this.animation.frames[frameIndex]();\r\n            }\r\n            else {\r\n                this.animation.onAnimateEnd();\r\n                this.animation = null;\r\n            }\r\n        }\r\n        this.timer = timer;\r\n        this.drawFrame();\r\n    }\r\n    /**\r\n     * Running requestAnimationFrame, and rendering process\r\n     */\r\n    start() {\r\n        this.update();\r\n        const loop = (timer) => {\r\n            this.render(timer);\r\n            requestAnimationFrame(loop);\r\n        };\r\n        requestAnimationFrame(loop);\r\n    }\r\n    /**\r\n     * Start a new animation process\r\n     *\r\n     * @param {FrameAction[]} frames - Frame list\r\n     * @param {number} duration - total animation duration\r\n     * @param {AnimationSuccessAction} onAnimateEnd - Animation callback function\r\n     */\r\n    startAnimation(frames, duration, onAnimateEnd) {\r\n        this.finishAnimation(); // finish the previous animation process\r\n        this.animation = {\r\n            frames,\r\n            duration,\r\n            durationFrame: duration / frames.length,\r\n            onAnimateEnd,\r\n            startedAt: this.timer,\r\n        };\r\n    }\r\n    /**\r\n     * End the current animation process and call the callback\r\n     */\r\n    finishAnimation() {\r\n        if (this.animation !== null) {\r\n            this.animation.frames[this.animation.frames.length - 1]();\r\n            if (this.animation.onAnimateEnd !== null) {\r\n                this.animation.onAnimateEnd();\r\n            }\r\n        }\r\n        this.animation = null;\r\n    }\r\n    /**\r\n     * Recalculate the size of the displayed area, and update the page orientation\r\n     */\r\n    update() {\r\n        this.boundsRect = null;\r\n        const orientation = this.calculateBoundsRect();\r\n        if (this.orientation !== orientation) {\r\n            this.orientation = orientation;\r\n            this.app.updateOrientation(orientation);\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the size and position of the book depending on the parent element and configuration parameters\r\n     */\r\n    calculateBoundsRect() {\r\n        let orientation = \"landscape\" /* LANDSCAPE */;\r\n        const blockWidth = this.getBlockWidth();\r\n        const middlePoint = {\r\n            x: blockWidth / 2,\r\n            y: this.getBlockHeight() / 2,\r\n        };\r\n        const ratio = this.setting.width / this.setting.height;\r\n        let pageWidth = this.setting.width;\r\n        let pageHeight = this.setting.height;\r\n        let left = middlePoint.x - pageWidth;\r\n        if (this.setting.size === \"stretch\" /* STRETCH */) {\r\n            if (blockWidth < this.setting.minWidth * 2 && this.app.getSettings().usePortrait)\r\n                orientation = \"portrait\" /* PORTRAIT */;\r\n            pageWidth =\r\n                orientation === \"portrait\" /* PORTRAIT */\r\n                    ? this.getBlockWidth()\r\n                    : this.getBlockWidth() / 2;\r\n            if (pageWidth > this.setting.maxWidth)\r\n                pageWidth = this.setting.maxWidth;\r\n            pageHeight = pageWidth / ratio;\r\n            if (pageHeight > this.getBlockHeight()) {\r\n                pageHeight = this.getBlockHeight();\r\n                pageWidth = pageHeight * ratio;\r\n            }\r\n            left =\r\n                orientation === \"portrait\" /* PORTRAIT */\r\n                    ? middlePoint.x - pageWidth / 2 - pageWidth\r\n                    : middlePoint.x - pageWidth;\r\n        }\r\n        else {\r\n            if (blockWidth < pageWidth * 2) {\r\n                if (this.app.getSettings().usePortrait) {\r\n                    orientation = \"portrait\" /* PORTRAIT */;\r\n                    left = middlePoint.x - pageWidth / 2 - pageWidth;\r\n                }\r\n            }\r\n        }\r\n        this.boundsRect = {\r\n            left,\r\n            top: middlePoint.y - pageHeight / 2,\r\n            width: pageWidth * 2,\r\n            height: pageHeight,\r\n            pageWidth: pageWidth,\r\n        };\r\n        return orientation;\r\n    }\r\n    /**\r\n     * Set the current parameters of the drop shadow\r\n     *\r\n     * @param {Point} pos - Shadow Position Start Point\r\n     * @param {number} angle - The angle of the shadows relative to the book\r\n     * @param {number} progress - Flipping progress in percent (0 - 100)\r\n     * @param {FlipDirection} direction - Flipping Direction, the direction of the shadow gradients\r\n     */\r\n    setShadowData(pos, angle, progress, direction) {\r\n        if (!this.app.getSettings().drawShadow)\r\n            return;\r\n        const maxShadowOpacity = 100 * this.getSettings().maxShadowOpacity;\r\n        this.shadow = {\r\n            pos,\r\n            angle,\r\n            width: (((this.getRect().pageWidth * 3) / 4) * progress) / 100,\r\n            opacity: ((100 - progress) * maxShadowOpacity) / 100 / 100,\r\n            direction,\r\n            progress: progress * 2,\r\n        };\r\n    }\r\n    /**\r\n     * Clear shadow\r\n     */\r\n    clearShadow() {\r\n        this.shadow = null;\r\n    }\r\n    /**\r\n     * Get parent block offset width\r\n     */\r\n    getBlockWidth() {\r\n        return this.app.getUI().getDistElement().offsetWidth;\r\n    }\r\n    /**\r\n     * Get parent block offset height\r\n     */\r\n    getBlockHeight() {\r\n        return this.app.getUI().getDistElement().offsetHeight;\r\n    }\r\n    /**\r\n     * Get current flipping direction\r\n     */\r\n    getDirection() {\r\n        return this.direction;\r\n    }\r\n    /**\r\n     * 小urrent size and position of the book\r\n     */\r\n    getRect() {\r\n        if (this.boundsRect === null)\r\n            this.calculateBoundsRect();\r\n        return this.boundsRect;\r\n    }\r\n    /**\r\n     * Get configuration object\r\n     */\r\n    getSettings() {\r\n        return this.app.getSettings();\r\n    }\r\n    /**\r\n     * Get current book orientation\r\n     */\r\n    getOrientation() {\r\n        return this.orientation;\r\n    }\r\n    /**\r\n     * Set page area while flipping\r\n     *\r\n     * @param direction\r\n     */\r\n    setPageRect(pageRect) {\r\n        this.pageRect = pageRect;\r\n    }\r\n    /**\r\n     * Set flipping direction\r\n     *\r\n     * @param direction\r\n     */\r\n    setDirection(direction) {\r\n        this.direction = direction;\r\n    }\r\n    /**\r\n     * Set right static book page\r\n     *\r\n     * @param page\r\n     */\r\n    setRightPage(page) {\r\n        if (page !== null)\r\n            page.setOrientation(1 /* RIGHT */);\r\n        this.rightPage = page;\r\n    }\r\n    /**\r\n     * Set left static book page\r\n     * @param page\r\n     */\r\n    setLeftPage(page) {\r\n        if (page !== null)\r\n            page.setOrientation(0 /* LEFT */);\r\n        this.leftPage = page;\r\n    }\r\n    /**\r\n     * Set next page at the time of flipping\r\n     * @param page\r\n     */\r\n    setBottomPage(page) {\r\n        if (page !== null)\r\n            page.setOrientation(this.direction === 1 /* BACK */ ? 0 /* LEFT */ : 1 /* RIGHT */);\r\n        this.bottomPage = page;\r\n    }\r\n    /**\r\n     * Set currently flipping page\r\n     *\r\n     * @param page\r\n     */\r\n    setFlippingPage(page) {\r\n        if (page !== null)\r\n            page.setOrientation(this.direction === 0 /* FORWARD */ &&\r\n                this.orientation !== \"portrait\" /* PORTRAIT */\r\n                ? 0 /* LEFT */\r\n                : 1 /* RIGHT */);\r\n        this.flippingPage = page;\r\n    }\r\n    /**\r\n     * Coordinate conversion function. Window coordinates -> to book coordinates\r\n     *\r\n     * @param {Point} pos - Global coordinates relative to the window\r\n     * @returns {Point} Coordinates relative to the book\r\n     */\r\n    convertToBook(pos) {\r\n        const rect = this.getRect();\r\n        return {\r\n            x: pos.x - rect.left,\r\n            y: pos.y - rect.top,\r\n        };\r\n    }\r\n    isSafari() {\r\n        return this.safari;\r\n    }\r\n    /**\r\n     * Coordinate conversion function. Window coordinates -> to current coordinates of the working page\r\n     *\r\n     * @param {Point} pos - Global coordinates relative to the window\r\n     * @param {FlipDirection} direction  - Current flipping direction\r\n     *\r\n     * @returns {Point} Coordinates relative to the work page\r\n     */\r\n    convertToPage(pos, direction) {\r\n        if (!direction)\r\n            direction = this.direction;\r\n        const rect = this.getRect();\r\n        const x = direction === 0 /* FORWARD */\r\n            ? pos.x - rect.left - rect.width / 2\r\n            : rect.width / 2 - pos.x + rect.left;\r\n        return {\r\n            x,\r\n            y: pos.y - rect.top,\r\n        };\r\n    }\r\n    /**\r\n     * Coordinate conversion function. Coordinates relative to the work page -> Window coordinates\r\n     *\r\n     * @param {Point} pos - Coordinates relative to the work page\r\n     * @param {FlipDirection} direction  - Current flipping direction\r\n     *\r\n     * @returns {Point} Global coordinates relative to the window\r\n     */\r\n    convertToGlobal(pos, direction) {\r\n        if (!direction)\r\n            direction = this.direction;\r\n        if (pos == null)\r\n            return null;\r\n        const rect = this.getRect();\r\n        const x = direction === 0 /* FORWARD */\r\n            ? pos.x + rect.left + rect.width / 2\r\n            : rect.width / 2 - pos.x + rect.left;\r\n        return {\r\n            x,\r\n            y: pos.y + rect.top,\r\n        };\r\n    }\r\n    /**\r\n     * Casting the coordinates of the corners of the rectangle in the coordinates relative to the window\r\n     *\r\n     * @param {RectPoints} rect - Coordinates of the corners of the rectangle relative to the work page\r\n     * @param {FlipDirection} direction  - Current flipping direction\r\n     *\r\n     * @returns {RectPoints} Coordinates of the corners of the rectangle relative to the window\r\n     */\r\n    convertRectToGlobal(rect, direction) {\r\n        if (!direction)\r\n            direction = this.direction;\r\n        return {\r\n            topLeft: this.convertToGlobal(rect.topLeft, direction),\r\n            topRight: this.convertToGlobal(rect.topRight, direction),\r\n            bottomLeft: this.convertToGlobal(rect.bottomLeft, direction),\r\n            bottomRight: this.convertToGlobal(rect.bottomRight, direction),\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Render/Render.ts?");

/***/ }),

/***/ "./src/Settings.ts":
/*!*************************!*\
  !*** ./src/Settings.ts ***!
  \*************************/
/*! exports provided: Settings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Settings\", function() { return Settings; });\nclass Settings {\r\n    constructor() {\r\n        this._default = {\r\n            startPage: 0,\r\n            size: \"fixed\" /* FIXED */,\r\n            width: 0,\r\n            height: 0,\r\n            minWidth: 0,\r\n            maxWidth: 0,\r\n            minHeight: 0,\r\n            maxHeight: 0,\r\n            drawShadow: true,\r\n            flippingTime: 1000,\r\n            usePortrait: true,\r\n            startZIndex: 0,\r\n            autoSize: true,\r\n            maxShadowOpacity: 1,\r\n            showCover: false,\r\n            mobileScrollSupport: true,\r\n            swipeDistance: 30,\r\n            clickEventForward: true,\r\n            useMouseEvents: true,\r\n            showPageCorners: true,\r\n        };\r\n    }\r\n    /**\r\n     * Processing parameters received from the user. Substitution default values\r\n     *\r\n     * @param userSetting\r\n     * @returns {FlipSetting} 小onfiguration object\r\n     */\r\n    getSettings(userSetting) {\r\n        const result = this._default;\r\n        Object.assign(result, userSetting);\r\n        if (result.size !== \"stretch\" /* STRETCH */ && result.size !== \"fixed\" /* FIXED */)\r\n            throw new Error('Invalid size type. Available only \"fixed\" and \"stretch\" value');\r\n        if (result.width <= 0 || result.height <= 0)\r\n            throw new Error('Invalid width or height');\r\n        if (result.flippingTime <= 0)\r\n            throw new Error('Invalid flipping time');\r\n        if (result.size === \"stretch\" /* STRETCH */) {\r\n            if (result.minWidth <= 0)\r\n                result.minWidth = 100;\r\n            if (result.maxWidth < result.minWidth)\r\n                result.maxWidth = 2000;\r\n            if (result.minHeight <= 0)\r\n                result.minHeight = 100;\r\n            if (result.maxHeight < result.minHeight)\r\n                result.maxHeight = 2000;\r\n        }\r\n        else {\r\n            result.minWidth = result.width;\r\n            result.maxWidth = result.width;\r\n            result.minHeight = result.height;\r\n            result.maxHeight = result.height;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/Settings.ts?");

/***/ }),

/***/ "./src/Style/stPageFlip.css":
/*!**********************************!*\
  !*** ./src/Style/stPageFlip.css ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./stPageFlip.css */ \"./node_modules/css-loader/dist/cjs.js!./src/Style/stPageFlip.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack://St/./src/Style/stPageFlip.css?");

/***/ }),

/***/ "./src/UI/CanvasUI.ts":
/*!****************************!*\
  !*** ./src/UI/CanvasUI.ts ***!
  \****************************/
/*! exports provided: CanvasUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasUI\", function() { return CanvasUI; });\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ \"./src/UI/UI.ts\");\n\r\n/**\r\n * UI for canvas mode\r\n */\r\nclass CanvasUI extends _UI__WEBPACK_IMPORTED_MODULE_0__[\"UI\"] {\r\n    constructor(inBlock, app, setting) {\r\n        super(inBlock, app, setting);\r\n        this.wrapper.innerHTML = '<canvas class=\"stf__canvas\"></canvas>';\r\n        this.canvas = inBlock.querySelectorAll('canvas')[0];\r\n        this.distElement = this.canvas;\r\n        this.resizeCanvas();\r\n        this.setHandlers();\r\n    }\r\n    resizeCanvas() {\r\n        const cs = getComputedStyle(this.canvas);\r\n        const width = parseInt(cs.getPropertyValue('width'), 10);\r\n        const height = parseInt(cs.getPropertyValue('height'), 10);\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n    /**\r\n     * Get canvas element\r\n     */\r\n    getCanvas() {\r\n        return this.canvas;\r\n    }\r\n    update() {\r\n        this.resizeCanvas();\r\n        this.app.getRender().update();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/UI/CanvasUI.ts?");

/***/ }),

/***/ "./src/UI/HTMLUI.ts":
/*!**************************!*\
  !*** ./src/UI/HTMLUI.ts ***!
  \**************************/
/*! exports provided: HTMLUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLUI\", function() { return HTMLUI; });\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ \"./src/UI/UI.ts\");\n\r\n/**\r\n * UI for HTML mode\r\n */\r\nclass HTMLUI extends _UI__WEBPACK_IMPORTED_MODULE_0__[\"UI\"] {\r\n    constructor(inBlock, app, setting, items) {\r\n        super(inBlock, app, setting);\r\n        // Second wrapper to HTML page\r\n        this.wrapper.insertAdjacentHTML('afterbegin', '<div class=\"stf__block\"></div>');\r\n        this.distElement = inBlock.querySelector('.stf__block');\r\n        for (const item of items) {\r\n            this.distElement.appendChild(item);\r\n        }\r\n        this.setHandlers();\r\n    }\r\n    /**\r\n     * Update page list from HTMLElements\r\n     *\r\n     * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\r\n     */\r\n    updateItems(items) {\r\n        this.removeHandlers();\r\n        this.distElement.innerHTML = \"\";\r\n        for (const item of items) {\r\n            this.distElement.appendChild(item);\r\n        }\r\n        this.setHandlers();\r\n    }\r\n    update() {\r\n        this.app.getRender().update();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/UI/HTMLUI.ts?");

/***/ }),

/***/ "./src/UI/UI.ts":
/*!**********************!*\
  !*** ./src/UI/UI.ts ***!
  \**********************/
/*! exports provided: UI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UI\", function() { return UI; });\n/**\r\n * UI Class, represents work with DOM\r\n */\r\nclass UI {\r\n    /**\r\n     * @constructor\r\n     *\r\n     * @param {HTMLElement} inBlock - Root HTML Element\r\n     * @param {PageFlip} app - PageFlip instanse\r\n     * @param {FlipSetting} setting - Configuration object\r\n     */\r\n    constructor(inBlock, app, setting) {\r\n        this.touchPoint = null;\r\n        this.swipeTimeout = 250;\r\n        this.onResize = () => {\r\n            this.update();\r\n        };\r\n        this.onMouseDown = (e) => {\r\n            if (this.checkTarget(e.target)) {\r\n                const pos = this.getMousePos(e.clientX, e.clientY);\r\n                this.app.startUserTouch(pos);\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        this.onTouchStart = (e) => {\r\n            if (this.checkTarget(e.target)) {\r\n                if (e.changedTouches.length > 0) {\r\n                    const t = e.changedTouches[0];\r\n                    const pos = this.getMousePos(t.clientX, t.clientY);\r\n                    this.touchPoint = {\r\n                        point: pos,\r\n                        time: Date.now(),\r\n                    };\r\n                    // part of swipe detection\r\n                    setTimeout(() => {\r\n                        if (this.touchPoint !== null) {\r\n                            this.app.startUserTouch(pos);\r\n                        }\r\n                    }, this.swipeTimeout);\r\n                    if (!this.app.getSettings().mobileScrollSupport)\r\n                        e.preventDefault();\r\n                }\r\n            }\r\n        };\r\n        this.onMouseUp = (e) => {\r\n            const pos = this.getMousePos(e.clientX, e.clientY);\r\n            this.app.userStop(pos);\r\n        };\r\n        this.onMouseMove = (e) => {\r\n            const pos = this.getMousePos(e.clientX, e.clientY);\r\n            this.app.userMove(pos, false);\r\n        };\r\n        this.onTouchMove = (e) => {\r\n            if (e.changedTouches.length > 0) {\r\n                const t = e.changedTouches[0];\r\n                const pos = this.getMousePos(t.clientX, t.clientY);\r\n                if (this.app.getSettings().mobileScrollSupport) {\r\n                    if (this.touchPoint !== null) {\r\n                        if (Math.abs(this.touchPoint.point.x - pos.x) > 10 ||\r\n                            this.app.getState() !== \"read\" /* READ */) {\r\n                            if (e.cancelable)\r\n                                this.app.userMove(pos, true);\r\n                        }\r\n                    }\r\n                    if (this.app.getState() !== \"read\" /* READ */) {\r\n                        e.preventDefault();\r\n                    }\r\n                }\r\n                else {\r\n                    this.app.userMove(pos, true);\r\n                }\r\n            }\r\n        };\r\n        this.onTouchEnd = (e) => {\r\n            if (e.changedTouches.length > 0) {\r\n                const t = e.changedTouches[0];\r\n                const pos = this.getMousePos(t.clientX, t.clientY);\r\n                let isSwipe = false;\r\n                // swipe detection\r\n                if (this.touchPoint !== null) {\r\n                    const dx = pos.x - this.touchPoint.point.x;\r\n                    const distY = Math.abs(pos.y - this.touchPoint.point.y);\r\n                    if (Math.abs(dx) > this.swipeDistance &&\r\n                        distY < this.swipeDistance * 2 &&\r\n                        Date.now() - this.touchPoint.time < this.swipeTimeout) {\r\n                        if (dx > 0) {\r\n                            this.app.flipPrev(this.touchPoint.point.y < this.app.getRender().getRect().height / 2\r\n                                ? \"top\" /* TOP */\r\n                                : \"bottom\" /* BOTTOM */);\r\n                        }\r\n                        else {\r\n                            this.app.flipNext(this.touchPoint.point.y < this.app.getRender().getRect().height / 2\r\n                                ? \"top\" /* TOP */\r\n                                : \"bottom\" /* BOTTOM */);\r\n                        }\r\n                        isSwipe = true;\r\n                    }\r\n                    this.touchPoint = null;\r\n                }\r\n                this.app.userStop(pos, isSwipe);\r\n            }\r\n        };\r\n        inBlock.classList.add('stf__parent');\r\n        // Add first wrapper\r\n        inBlock.insertAdjacentHTML('afterbegin', '<div class=\"stf__wrapper\"></div>');\r\n        this.wrapper = inBlock.querySelector('.stf__wrapper');\r\n        this.app = app;\r\n        const k = this.app.getSettings().usePortrait ? 1 : 2;\r\n        // Setting block sizes based on configuration\r\n        inBlock.style.minWidth = setting.minWidth * k + 'px';\r\n        inBlock.style.minHeight = setting.minHeight + 'px';\r\n        if (setting.size === \"fixed\" /* FIXED */) {\r\n            inBlock.style.minWidth = setting.width * k + 'px';\r\n            inBlock.style.minHeight = setting.height + 'px';\r\n        }\r\n        if (setting.autoSize) {\r\n            inBlock.style.width = '100%';\r\n            inBlock.style.maxWidth = setting.maxWidth * 2 + 'px';\r\n        }\r\n        inBlock.style.display = 'block';\r\n        window.addEventListener('resize', this.onResize, false);\r\n        this.swipeDistance = setting.swipeDistance;\r\n    }\r\n    /**\r\n     * Destructor. Remove all HTML elements and all event handlers\r\n     */\r\n    destroy() {\r\n        if (this.app.getSettings().useMouseEvents)\r\n            this.removeHandlers();\r\n        this.distElement.remove();\r\n        this.wrapper.remove();\r\n    }\r\n    /**\r\n     * Get parent element for book\r\n     *\r\n     * @returns {HTMLElement}\r\n     */\r\n    getDistElement() {\r\n        return this.distElement;\r\n    }\r\n    /**\r\n     * Get wrapper element\r\n     *\r\n     * @returns {HTMLElement}\r\n     */\r\n    getWrapper() {\r\n        return this.wrapper;\r\n    }\r\n    /**\r\n     * Updates styles and sizes based on book orientation\r\n     *\r\n     * @param {Orientation} orientation - New book orientation\r\n     */\r\n    setOrientationStyle(orientation) {\r\n        this.wrapper.classList.remove('--portrait', '--landscape');\r\n        if (orientation === \"portrait\" /* PORTRAIT */) {\r\n            if (this.app.getSettings().autoSize)\r\n                this.wrapper.style.paddingBottom =\r\n                    (this.app.getSettings().height / this.app.getSettings().width) * 100 + '%';\r\n            this.wrapper.classList.add('--portrait');\r\n        }\r\n        else {\r\n            if (this.app.getSettings().autoSize)\r\n                this.wrapper.style.paddingBottom =\r\n                    (this.app.getSettings().height / (this.app.getSettings().width * 2)) * 100 +\r\n                        '%';\r\n            this.wrapper.classList.add('--landscape');\r\n        }\r\n        this.update();\r\n    }\r\n    removeHandlers() {\r\n        window.removeEventListener('resize', this.onResize);\r\n        this.distElement.removeEventListener('mousedown', this.onMouseDown);\r\n        this.distElement.removeEventListener('touchstart', this.onTouchStart);\r\n        window.removeEventListener('mousemove', this.onMouseMove);\r\n        window.removeEventListener('touchmove', this.onTouchMove);\r\n        window.removeEventListener('mouseup', this.onMouseUp);\r\n        window.removeEventListener('touchend', this.onTouchEnd);\r\n    }\r\n    setHandlers() {\r\n        if (!this.app.getSettings().useMouseEvents)\r\n            return;\r\n        this.distElement.addEventListener('mousedown', this.onMouseDown);\r\n        this.distElement.addEventListener('touchstart', this.onTouchStart);\r\n        window.addEventListener('mousemove', this.onMouseMove);\r\n        window.addEventListener('touchmove', this.onTouchMove, {\r\n            passive: !this.app.getSettings().mobileScrollSupport,\r\n        });\r\n        window.addEventListener('mouseup', this.onMouseUp);\r\n        window.addEventListener('touchend', this.onTouchEnd);\r\n    }\r\n    /**\r\n     * Convert global coordinates to relative book coordinates\r\n     *\r\n     * @param x\r\n     * @param y\r\n     */\r\n    getMousePos(x, y) {\r\n        const rect = this.distElement.getBoundingClientRect();\r\n        return {\r\n            x: x - rect.left,\r\n            y: y - rect.top,\r\n        };\r\n    }\r\n    checkTarget(targer) {\r\n        if (!this.app.getSettings().clickEventForward)\r\n            return true;\r\n        if (['a', 'button'].includes(targer.tagName.toLowerCase())) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://St/./src/UI/UI.ts?");

/***/ })

/******/ });